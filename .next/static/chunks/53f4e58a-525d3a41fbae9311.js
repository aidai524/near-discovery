"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5204],{77351:function(e,t,a){a.d(t,{DMg:function(){return l9},FnL:function(){return aL},KBB:function(){return rj},TCK:function(){return tZ},VZp:function(){return aj},jrT:function(){return iu}});var s,r,i,n,l,u,o=a(73494),c=a(72043),h=a(51225),m=a(97262),d=a(34155);/*!
 * Copyright (c) 2014, GlobalSign
 * Copyright (c) 2015-2019, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the {organization} nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */let f=new ArrayBuffer(0);class g extends TypeError{constructor(){super(...arguments),this.name=g.NAME}static isType(e,t){if("string"==typeof t){if("Array"===t&&Array.isArray(e)||"ArrayBuffer"===t&&e instanceof ArrayBuffer)return!0;if("ArrayBufferView"===t&&ArrayBuffer.isView(e))return!0;if(typeof e===t)return!0}else if(e instanceof t)return!0;return!1}static assert(e,t,...a){for(let t of a)if(this.isType(e,t))return;let s=a.map(e=>e instanceof Function&&"name"in e?e.name:`${e}`);throw new g(`Parameter '${t}' is not of type ${s.length>1?`(${s.join(" or ")})`:s[0]}`)}}g.NAME="ArgumentError";class p extends TypeError{constructor(e,t=null,a){super(),this.name=p.NAME,this.field=e,t&&(this.target=t),a?this.message=a:this.message=`Absent mandatory parameter '${e}' ${t?` in '${t}'`:""}`}static assert(...e){let t,a,s=null;for(let r of("string"==typeof e[0]?(s=e[0],t=e[1],a=e.slice(2)):(t=e[0],a=e.slice(1)),g.assert(t,"parameters","object"),a)){let e=t[r];if(null==e)throw new p(r,s)}}static assertEmpty(e,t,a){if(null==e)throw new p(t,a)}}p.NAME="ParameterError";class S extends Error{static assertSchema(e,t){if(!e.verified)throw Error(`Object's schema was not verified against input data for ${t}`)}static assert(e,t){if(-1===e.offset)throw new S(`Error during parsing of ASN.1 data. Data is not correct for '${t}'.`)}constructor(e){super(e),this.name="AsnError"}}class y{static blockName(){return this.CLASS_NAME}static fromBER(e){let t=o.fromBER(e);S.assert(t,this.name);try{return new this({schema:t.result})}catch(e){throw new S(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`)}}static defaultValues(e){throw Error(`Invalid member name for ${this.CLASS_NAME} class: ${e}`)}static schema(e={}){throw Error(`Method '${this.CLASS_NAME}.schema' should be overridden`)}get className(){return this.constructor.CLASS_NAME}toString(e="hex"){let t;try{t=this.toSchema()}catch{t=this.toSchema(!0)}return c.ep.ToString(t.toBER(),e)}}function w(e){let t=!1,a="",s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(a+=" ",t=!1),a+=s[e]);return a.toLowerCase()}y.CLASS_NAME="PkiObject";let v="type",b="value";class A extends y{constructor(e={}){super(),this.type=h.H$(e,v,A.defaultValues(v)),this.value=h.H$(e,b,A.defaultValues(b)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case v:return"";case b:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.type||""}),new o.Any({name:t.value||""})]})}fromSchema(e){h.ze(e,[v,"typeValue"]);let t=o.compareSchema(e,e,A.schema({names:{type:v,value:"typeValue"}}));S.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.type}),this.value]})}toJSON(){let e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){let t=[o.Utf8String.blockName(),o.BmpString.blockName(),o.UniversalString.blockName(),o.NumericString.blockName(),o.PrintableString.blockName(),o.TeletexString.blockName(),o.VideotexString.blockName(),o.IA5String.blockName(),o.GraphicString.blockName(),o.VisibleString.blockName(),o.GeneralString.blockName(),o.CharacterString.blockName()];if(e instanceof ArrayBuffer)return c.vJ.isEqual(this.value.valueBeforeDecodeView,e);if(e.constructor.blockName()===A.blockName()){if(this.type!==e.type)return!1;let a=[!1,!1],s=this.value.constructor.blockName();for(let r of t)s===r&&(a[0]=!0),e.value.constructor.blockName()===r&&(a[1]=!0);if(a[0]!==a[1])return!1;let r=a[0]&&a[1];if(r){let t=w(this.value.valueBlock.value),a=w(e.value.valueBlock.value);if(0!==t.localeCompare(a))return!1}else if(!c.vJ.isEqual(this.value.valueBeforeDecodeView,e.value.valueBeforeDecodeView))return!1;return!0}return!1}}A.CLASS_NAME="AttributeTypeAndValue";let k="typesAndValues",C="valueBeforeDecode";class N extends y{constructor(e={}){super(),this.typesAndValues=h.H$(e,k,N.defaultValues(k)),this.valueBeforeDecode=h.H$(e,C,N.defaultValues(C)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case k:return[];case C:return f;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case k:return 0===t.length;case C:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.repeatedSequence||"",value:new o.Set({value:[new o.Repeated({name:t.repeatedSet||"",value:A.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){h.ze(e,["RDN",k]);let t=o.compareSchema(e,e,N.schema({names:{blockName:"RDN",repeatedSet:k}}));S.assertSchema(t,this.className),k in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new A({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecodeView.slice().buffer}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new o.Sequence({value:[new o.Set({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});let e=o.fromBER(this.valueBeforeDecode);if(S.assert(e,"RelativeDistinguishedNames"),!(e.result instanceof o.Sequence))throw Error("ASN.1 result should be SEQUENCE");return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof N){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(let[t,a]of this.typesAndValues.entries())if(!1===a.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&h.dN(this.valueBeforeDecode,e)}}N.CLASS_NAME="RelativeDistinguishedNames";let V="type",I="value";class B extends y{constructor(e={}){super(),this.type=h.H$(e,V,B.defaultValues(V)),this.value=h.H$(e,I,B.defaultValues(I)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case V:return 9;case I:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case V:return t===B.defaultValues(e);case I:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[new o.Constructed({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||"",value:[new o.ObjectIdentifier,new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any]})]}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new o.Constructed({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||"",value:[function(e={},t=!1){let a=h.H$(e,"names",{});return new o.Sequence({optional:t,value:[new o.Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:a.country_name||"",value:[new o.Choice({value:[new o.NumericString,new o.PrintableString]})]}),new o.Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:a.administration_domain_name||"",value:[new o.Choice({value:[new o.NumericString,new o.PrintableString]})]}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:a.network_address||"",isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:a.terminal_identifier||"",isHexOnly:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:a.private_domain_name||"",value:[new o.Choice({value:[new o.NumericString,new o.PrintableString]})]}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:a.organization_name||"",isHexOnly:!0}),new o.Primitive({optional:!0,name:a.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new o.Constructed({optional:!0,name:a.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new o.Primitive({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new o.Constructed({optional:!0,name:a.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new o.Repeated({value:new o.PrintableString})]})]})}(t.builtInStandardAttributes||{},!1),function(e=!1){return new o.Sequence({optional:e,value:[new o.PrintableString,new o.PrintableString]})}(!0),function(e=!1){return new o.Set({optional:e,value:[new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Any]})]})}(!0)]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||"",value:[N.schema(t.directoryName||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Choice({value:[new o.TeletexString,new o.PrintableString,new o.UniversalString,new o.Utf8String,new o.BmpString]})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.Choice({value:[new o.TeletexString,new o.PrintableString,new o.UniversalString,new o.Utf8String,new o.BmpString]})]})]}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){h.ze(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);let t=o.compareSchema(e,e,B.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));switch(S.assertSchema(t,this.className),this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:case 3:this.value=t.result.blockName;break;case 1:case 2:case 6:{let e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"GeneralName value"),this.value=s.result.valueBlock.value}break;case 4:this.value=new N({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new o.OctetString({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{let e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"GeneralName registeredID"),this.value=s.result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new o.Constructed({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{let e=new o.IA5String({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new o.Constructed({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{let e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{let e=new o.ObjectIdentifier({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return B.schema()}}toJSON(){let e={type:this.type,value:""};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(e){}return e}}B.CLASS_NAME="GeneralName";let E="accessMethod",H="accessLocation",D=[E,H];class O extends y{constructor(e={}){super(),this.accessMethod=h.H$(e,E,O.defaultValues(E)),this.accessLocation=h.H$(e,H,O.defaultValues(H)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case E:return"";case H:return new B;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.accessMethod||""}),B.schema(t.accessLocation||{})]})}fromSchema(e){h.ze(e,D);let t=o.compareSchema(e,e,O.schema({names:{accessMethod:E,accessLocation:{names:{blockName:H}}}}));S.assertSchema(t,this.className),this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new B({schema:t.result.accessLocation})}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}O.CLASS_NAME="AccessDescription";let x="seconds",$="millis",P="micros";class q extends y{constructor(e={}){super(),x in e&&(this.seconds=h.H$(e,x,q.defaultValues(x))),$ in e&&(this.millis=h.H$(e,$,q.defaultValues($))),P in e&&(this.micros=h.H$(e,P,q.defaultValues(P))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case x:case $:case P:return 0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case x:case $:case P:return t===q.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",optional:!0,value:[new o.Integer({optional:!0,name:t.seconds||""}),new o.Primitive({name:t.millis||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Primitive({name:t.micros||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){h.ze(e,[x,$,P]);let t=o.compareSchema(e,e,q.schema({names:{seconds:x,millis:$,micros:P}}));if(S.assertSchema(t,this.className),"seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){let e=new o.Integer({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){let e=new o.Integer({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){let e=[];if(void 0!==this.seconds&&e.push(new o.Integer({value:this.seconds})),void 0!==this.millis){let t=new o.Integer({value:this.millis});e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHexView}))}if(void 0!==this.micros){let t=new o.Integer({value:this.micros});e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHexView}))}return new o.Sequence({value:e})}toJSON(){let e={};return void 0!==this.seconds&&(e.seconds=this.seconds),void 0!==this.millis&&(e.millis=this.millis),void 0!==this.micros&&(e.micros=this.micros),e}}q.CLASS_NAME="Accuracy";let K="algorithmId",R="algorithmParams",J="algorithm",j="params",U=[J,j];class T extends y{constructor(e={}){super(),this.algorithmId=h.H$(e,K,T.defaultValues(K)),R in e&&(this.algorithmParams=h.H$(e,R,T.defaultValues(R))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case K:return"";case R:return new o.Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case K:return""===t;case R:return t instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",optional:t.optional||!1,value:[new o.ObjectIdentifier({name:t.algorithmIdentifier||""}),new o.Any({name:t.algorithmParams||"",optional:!0})]})}fromSchema(e){h.ze(e,U);let t=o.compareSchema(e,e,T.schema({names:{algorithmIdentifier:J,algorithmParams:j}}));S.assertSchema(t,this.className),this.algorithmId=t.result.algorithm.valueBlock.toString(),j in t.result&&(this.algorithmParams=t.result.params)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.algorithmId})),!this.algorithmParams||this.algorithmParams instanceof o.Any||e.push(this.algorithmParams),new o.Sequence({value:e})}toJSON(){let e={algorithmId:this.algorithmId};return!this.algorithmParams||this.algorithmParams instanceof o.Any||(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof T&&this.algorithmId===e.algorithmId&&(this.algorithmParams?!!e.algorithmParams&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!e.algorithmParams)}}T.CLASS_NAME="AlgorithmIdentifier";let L="altNames",M=[L];class _ extends y{constructor(e={}){super(),this.altNames=h.H$(e,L,_.defaultValues(L)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===L?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.altNames||"",value:B.schema()})]})}fromSchema(e){h.ze(e,M);let t=o.compareSchema(e,e,_.schema({names:{altNames:L}}));S.assertSchema(t,this.className),L in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new B({schema:e})))}toSchema(){return new o.Sequence({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}_.CLASS_NAME="AltName";let W="type",z="values",F=[W,z];class G extends y{constructor(e={}){super(),this.type=h.H$(e,W,G.defaultValues(W)),this.values=h.H$(e,z,G.defaultValues(z)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case W:return"";case z:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case W:return""===t;case z:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.type||""}),new o.Set({name:t.setName||"",value:[new o.Repeated({name:t.values||"",value:new o.Any})]})]})}fromSchema(e){h.ze(e,F);let t=o.compareSchema(e,e,G.schema({names:{type:W,values:z}}));S.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.type}),new o.Set({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}G.CLASS_NAME="Attribute";let Q="notBeforeTime",Z="notAfterTime",X=[Q,Z];class Y extends y{constructor(e={}){super(),this.notBeforeTime=h.H$(e,Q,Y.defaultValues(Q)),this.notAfterTime=h.H$(e,Z,Y.defaultValues(Z)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Q:case Z:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.GeneralizedTime({name:t.notBeforeTime||""}),new o.GeneralizedTime({name:t.notAfterTime||""})]})}fromSchema(e){h.ze(e,X);let t=o.compareSchema(e,e,Y.schema({names:{notBeforeTime:Q,notAfterTime:Z}}));S.assertSchema(t,this.className),this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new o.Sequence({value:[new o.GeneralizedTime({valueDate:this.notBeforeTime}),new o.GeneralizedTime({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}Y.CLASS_NAME="AttCertValidityPeriod";let ee="names",et="generalNames";class ea extends y{constructor(e={}){super(),this.names=h.H$(e,ee,ea.defaultValues(ee)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"names"===e?[]:super.defaultValues(e)}static schema(e={},t=!1){let a=h.H$(e,ee,{});return new o.Sequence({optional:t,name:a.blockName||"",value:[new o.Repeated({name:a.generalNames||"",value:B.schema()})]})}fromSchema(e){h.ze(e,[ee,et]);let t=o.compareSchema(e,e,ea.schema({names:{blockName:ee,generalNames:et}}));S.assertSchema(t,this.className),this.names=Array.from(t.result.generalNames,e=>new B({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}ea.CLASS_NAME="GeneralNames";let es="2.5.29.17",er="2.5.29.18",ei="2.5.29.19",en="2.5.29.28",el="2.5.29.29",eu="2.5.29.30",eo="2.5.29.31",ec="2.5.29.46",eh="2.5.29.32",em="2.5.29.32.0",ed="2.5.29.33",ef="2.5.29.35",eg="2.5.29.36",ep="1.3.6.1.5.5.7.1.1",eS="1.2.840.113549.1.7.1",ey="1.2.840.113549.1.7.2",ew="1.2.840.113549.1.7.3",ev="1.2.840.113549.1.7.6",eb="1.2.840.113549.1.9.22.1",eA="1.2.840.113549.1.9.22.3",ek="1.2.840.113549.1.9.23.1",eC="1.3.6.1.5.5.7.48.1.1",eN="keyIdentifier",eV="authorityCertIssuer",eI="authorityCertSerialNumber",eB=[eN,eV,eI];class eE extends y{constructor(e={}){super(),eN in e&&(this.keyIdentifier=h.H$(e,eN,eE.defaultValues(eN))),eV in e&&(this.authorityCertIssuer=h.H$(e,eV,eE.defaultValues(eV))),eI in e&&(this.authorityCertSerialNumber=h.H$(e,eI,eE.defaultValues(eI))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eN:return new o.OctetString;case eV:return[];case eI:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Primitive({name:t.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.authorityCertIssuer||"",value:B.schema()})]}),new o.Primitive({name:t.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){h.ze(e,eB);let t=o.compareSchema(e,e,eE.schema({names:{keyIdentifier:eN,authorityCertIssuer:eV,authorityCertSerialNumber:eI}}));S.assertSchema(t,this.className),eN in t.result&&(this.keyIdentifier=new o.OctetString({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),eV in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new B({schema:e}))),eI in t.result&&(this.authorityCertSerialNumber=new o.Integer({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){let e=[];return this.keyIdentifier&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHexView})),this.authorityCertIssuer&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),this.authorityCertSerialNumber&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHexView})),new o.Sequence({value:e})}toJSON(){let e={};return this.keyIdentifier&&(e.keyIdentifier=this.keyIdentifier.toJSON()),this.authorityCertIssuer&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),this.authorityCertSerialNumber&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}eE.CLASS_NAME="AuthorityKeyIdentifier";let eH="pathLenConstraint";class eD extends y{constructor(e={}){super(),this.cA=h.H$(e,"cA",!1),eH in e&&(this.pathLenConstraint=h.H$(e,eH,0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"cA"!==e&&super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Boolean({optional:!0,name:t.cA||""}),new o.Integer({optional:!0,name:t.pathLenConstraint||""})]})}fromSchema(e){h.ze(e,["cA",eH]);let t=o.compareSchema(e,e,eD.schema({names:{cA:"cA",pathLenConstraint:eH}}));S.assertSchema(t,this.className),"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),eH in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){let e=[];return this.cA!==eD.defaultValues("cA")&&e.push(new o.Boolean({value:this.cA})),eH in this&&(this.pathLenConstraint instanceof o.Integer?e.push(this.pathLenConstraint):e.push(new o.Integer({value:this.pathLenConstraint}))),new o.Sequence({value:e})}toJSON(){let e={};return this.cA!==eD.defaultValues("cA")&&(e.cA=this.cA),eH in this&&(this.pathLenConstraint instanceof o.Integer?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}eD.CLASS_NAME="BasicConstraints";let eO="certificateIndex",ex="keyIndex";class e$ extends y{constructor(e={}){super(),this.certificateIndex=h.H$(e,eO,e$.defaultValues(eO)),this.keyIndex=h.H$(e,ex,e$.defaultValues(ex)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eO:case ex:return 0;default:return super.defaultValues(e)}}static schema(){return new o.Integer}fromSchema(e){if(e.constructor.blockName()!==o.Integer.blockName())throw Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0),a=new Uint8Array(t);switch(!0){case t.byteLength<4:{let e=new ArrayBuffer(4),s=new Uint8Array(e);s.set(a,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{let e=new ArrayBuffer(4),s=new Uint8Array(e);s.set(a.slice(0,4)),t=e.slice(0)}}let s=t.slice(0,2),r=new Uint8Array(s),i=r[0];r[0]=r[1],r[1]=i;let n=new Uint16Array(s);this.keyIndex=n[0];let l=t.slice(2),u=new Uint8Array(l);i=u[0],u[0]=u[1],u[1]=i;let c=new Uint16Array(l);this.certificateIndex=c[0]}toSchema(){let e=new ArrayBuffer(2),t=new Uint16Array(e);t[0]=this.certificateIndex;let a=new Uint8Array(e),s=a[0];a[0]=a[1],a[1]=s;let r=new ArrayBuffer(2),i=new Uint16Array(r);i[0]=this.keyIndex;let n=new Uint8Array(r);return s=n[0],n[0]=n[1],n[1]=s,new o.Integer({valueHex:h.hk(r,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}e$.CLASS_NAME="CAVersion";let eP="policyQualifierId",eq="qualifier",eK=[eP,eq];class eR extends y{constructor(e={}){super(),this.policyQualifierId=h.H$(e,eP,eR.defaultValues(eP)),this.qualifier=h.H$(e,eq,eR.defaultValues(eq)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eP:return"";case eq:return new o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.policyQualifierId||""}),new o.Any({name:t.qualifier||""})]})}fromSchema(e){h.ze(e,eK);let t=o.compareSchema(e,e,eR.schema({names:{policyQualifierId:eP,qualifier:eq}}));S.assertSchema(t,this.className),this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}eR.CLASS_NAME="PolicyQualifierInfo";let eJ="policyIdentifier",ej="policyQualifiers",eU=[eJ,ej];class eT extends y{constructor(e={}){super(),this.policyIdentifier=h.H$(e,eJ,eT.defaultValues(eJ)),ej in e&&(this.policyQualifiers=h.H$(e,ej,eT.defaultValues(ej))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eJ:return"";case ej:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.policyIdentifier||""}),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.policyQualifiers||"",value:eR.schema()})]})]})}fromSchema(e){h.ze(e,eU);let t=o.compareSchema(e,e,eT.schema({names:{policyIdentifier:eJ,policyQualifiers:ej}}));S.assertSchema(t,this.className),this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),ej in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new eR({schema:e})))}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.policyIdentifier})),this.policyQualifiers&&e.push(new o.Sequence({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={policyIdentifier:this.policyIdentifier};return this.policyQualifiers&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}eT.CLASS_NAME="PolicyInformation";let eL="certificatePolicies",eM=[eL];class e_ extends y{constructor(e={}){super(),this.certificatePolicies=h.H$(e,eL,e_.defaultValues(eL)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===eL?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.certificatePolicies||"",value:eT.schema()})]})}fromSchema(e){h.ze(e,eM);let t=o.compareSchema(e,e,e_.schema({names:{certificatePolicies:eL}}));S.assertSchema(t,this.className),this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new eT({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}e_.CLASS_NAME="CertificatePolicies";let eW="templateID",ez="templateMajorVersion",eF="templateMinorVersion",eG=[eW,ez,eF];class eQ extends y{constructor(e={}){super(),this.templateID=h.H$(e,eW,eQ.defaultValues(eW)),ez in e&&(this.templateMajorVersion=h.H$(e,ez,eQ.defaultValues(ez))),eF in e&&(this.templateMinorVersion=h.H$(e,eF,eQ.defaultValues(eF))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eW:return"";case ez:case eF:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.templateID||""}),new o.Integer({name:t.templateMajorVersion||"",optional:!0}),new o.Integer({name:t.templateMinorVersion||"",optional:!0})]})}fromSchema(e){h.ze(e,eG);let t=o.compareSchema(e,e,eQ.schema({names:{templateID:eW,templateMajorVersion:ez,templateMinorVersion:eF}}));S.assertSchema(t,this.className),this.templateID=t.result.templateID.valueBlock.toString(),ez in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),eF in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.templateID})),ez in this&&e.push(new o.Integer({value:this.templateMajorVersion})),eF in this&&e.push(new o.Integer({value:this.templateMinorVersion})),new o.Sequence({value:e})}toJSON(){let e={templateID:this.templateID};return ez in this&&(e.templateMajorVersion=this.templateMajorVersion),eF in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}let eZ="distributionPoint",eX="distributionPointNames",eY="reasons",e1="cRLIssuer",e0="cRLIssuerNames",e2=[eZ,eX,eY,e1,e0];class e3 extends y{constructor(e={}){super(),eZ in e&&(this.distributionPoint=h.H$(e,eZ,e3.defaultValues(eZ))),eY in e&&(this.reasons=h.H$(e,eY,e3.defaultValues(eY))),e1 in e&&(this.cRLIssuer=h.H$(e,e1,e3.defaultValues(e1))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eZ:return[];case eY:return new o.BitString;case e1:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Choice({value:[new o.Constructed({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.distributionPointNames||"",value:B.schema()})]}),new o.Constructed({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:N.schema().valueBlock.value})]})]}),new o.Primitive({name:t.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new o.Constructed({name:t.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new o.Repeated({name:t.cRLIssuerNames||"",value:B.schema()})]})]})}fromSchema(e){h.ze(e,e2);let t=o.compareSchema(e,e,e3.schema({names:{distributionPoint:eZ,distributionPointNames:eX,reasons:eY,cRLIssuer:e1,cRLIssuerNames:e0}}));S.assertSchema(t,this.className),eZ in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new B({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new N({schema:new o.Sequence({value:t.result.distributionPoint.valueBlock.value})}))),eY in t.result&&(this.reasons=new o.BitString({valueHex:t.result.reasons.valueBlock.valueHex})),e1 in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new B({schema:e})))}toSchema(){let e=[];if(this.distributionPoint){let t;t=new o.Constructed(this.distributionPoint instanceof Array?{idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}:{idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return this.reasons&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHexView})),this.cRLIssuer&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.reasons&&(e.reasons=this.reasons.toJSON()),this.cRLIssuer&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}e3.CLASS_NAME="DistributionPoint";let e4="distributionPoints",e8=[e4];class e5 extends y{constructor(e={}){super(),this.distributionPoints=h.H$(e,e4,e5.defaultValues(e4)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===e4?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.distributionPoints||"",value:e3.schema()})]})}fromSchema(e){h.ze(e,e8);let t=o.compareSchema(e,e,e5.schema({names:{distributionPoints:e4}}));S.assertSchema(t,this.className),this.distributionPoints=Array.from(t.result.distributionPoints,e=>new e3({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}e5.CLASS_NAME="CRLDistributionPoints";let e6="keyPurposes",e9=[e6];class e7 extends y{constructor(e={}){super(),this.keyPurposes=h.H$(e,e6,e7.defaultValues(e6)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===e6?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.keyPurposes||"",value:new o.ObjectIdentifier})]})}fromSchema(e){h.ze(e,e9);let t=o.compareSchema(e,e,e7.schema({names:{keyPurposes:e6}}));S.assertSchema(t,this.className),this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new o.Sequence({value:Array.from(this.keyPurposes,e=>new o.ObjectIdentifier({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}e7.CLASS_NAME="ExtKeyUsage";let te="accessDescriptions";class tt extends y{constructor(e={}){super(),this.accessDescriptions=h.H$(e,te,tt.defaultValues(te)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===te?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.accessDescriptions||"",value:O.schema()})]})}fromSchema(e){h.ze(e,[te]);let t=o.compareSchema(e,e,tt.schema({names:{accessDescriptions:te}}));S.assertSchema(t,this.className),this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new O({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}tt.CLASS_NAME="InfoAccess";let ta="distributionPoint",ts="distributionPointNames",tr="onlyContainsUserCerts",ti="onlyContainsCACerts",tn="onlySomeReasons",tl="indirectCRL",tu="onlyContainsAttributeCerts",to=[ta,ts,tr,ti,tn,tl,tu];class tc extends y{constructor(e={}){super(),ta in e&&(this.distributionPoint=h.H$(e,ta,tc.defaultValues(ta))),this.onlyContainsUserCerts=h.H$(e,tr,tc.defaultValues(tr)),this.onlyContainsCACerts=h.H$(e,ti,tc.defaultValues(ti)),tn in e&&(this.onlySomeReasons=h.H$(e,tn,tc.defaultValues(tn))),this.indirectCRL=h.H$(e,tl,tc.defaultValues(tl)),this.onlyContainsAttributeCerts=h.H$(e,tu,tc.defaultValues(tu)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ta:return[];case tr:case ti:return!1;case tn:return 0;case tl:case tu:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Choice({value:[new o.Constructed({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.distributionPointNames||"",value:B.schema()})]}),new o.Constructed({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:N.schema().valueBlock.value})]})]}),new o.Primitive({name:t.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new o.Primitive({name:t.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new o.Primitive({name:t.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new o.Primitive({name:t.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new o.Primitive({name:t.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){h.ze(e,to);let t=o.compareSchema(e,e,tc.schema({names:{distributionPoint:ta,distributionPointNames:ts,onlyContainsUserCerts:tr,onlyContainsCACerts:ti,onlySomeReasons:tn,indirectCRL:tl,onlyContainsAttributeCerts:tu}}));if(S.assertSchema(t,this.className),ta in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new B({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new N({schema:new o.Sequence({value:t.result.distributionPoint.valueBlock.value})});break;default:throw Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if(tr in t.result){let e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if(ti in t.result){let e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if(tn in t.result){let e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if(tl in t.result){let e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if(tu in t.result){let e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){let e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):((t=this.distributionPoint.toSchema()).idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==tc.defaultValues(tr)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==tc.defaultValues(ti)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),void 0!==this.onlySomeReasons){let t=new ArrayBuffer(1),a=new Uint8Array(t);a[0]=this.onlySomeReasons,e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==tc.defaultValues(tl)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==tc.defaultValues(tu)&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new o.Sequence({value:e})}toJSON(){let e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==tc.defaultValues(tr)&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==tc.defaultValues(ti)&&(e.onlyContainsCACerts=this.onlyContainsCACerts),tn in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==tc.defaultValues(tl)&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==tc.defaultValues(tu)&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}tc.CLASS_NAME="IssuingDistributionPoint";let th="base",tm="minimum",td="maximum",tf=[th,tm,td];class tg extends y{constructor(e={}){super(),this.base=h.H$(e,th,tg.defaultValues(th)),this.minimum=h.H$(e,tm,tg.defaultValues(tm)),td in e&&(this.maximum=h.H$(e,td,tg.defaultValues(td))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case th:return new B;case tm:case td:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[B.schema(t.base||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.minimum||""})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Integer({name:t.maximum||""})]})]})}fromSchema(e){h.ze(e,tf);let t=o.compareSchema(e,e,tg.schema({names:{base:{names:{blockName:th}},minimum:tm,maximum:td}}));S.assertSchema(t,this.className),this.base=new B({schema:t.result.base}),tm in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),td in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){let e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof o.Integer?this.minimum:new o.Integer({value:this.minimum}),e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(td in this){let t=0;t=this.maximum instanceof o.Integer?this.maximum:new o.Integer({value:this.maximum}),e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new o.Sequence({value:e})}toJSON(){let e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),void 0!==this.maximum&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}tg.CLASS_NAME="GeneralSubtree";let tp="permittedSubtrees",tS="excludedSubtrees",ty=[tp,tS];class tw extends y{constructor(e={}){super(),tp in e&&(this.permittedSubtrees=h.H$(e,tp,tw.defaultValues(tp))),tS in e&&(this.excludedSubtrees=h.H$(e,tS,tw.defaultValues(tS))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tp:case tS:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.permittedSubtrees||"",value:tg.schema()})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.excludedSubtrees||"",value:tg.schema()})]})]})}fromSchema(e){h.ze(e,ty);let t=o.compareSchema(e,e,tw.schema({names:{permittedSubtrees:tp,excludedSubtrees:tS}}));S.assertSchema(t,this.className),tp in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new tg({schema:e}))),tS in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new tg({schema:e})))}toSchema(){let e=[];return this.permittedSubtrees&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),this.excludedSubtrees&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={};return this.permittedSubtrees&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),this.excludedSubtrees&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}tw.CLASS_NAME="NameConstraints";let tv="requireExplicitPolicy",tb="inhibitPolicyMapping",tA=[tv,tb];class tk extends y{constructor(e={}){super(),tv in e&&(this.requireExplicitPolicy=h.H$(e,tv,tk.defaultValues(tv))),tb in e&&(this.inhibitPolicyMapping=h.H$(e,tb,tk.defaultValues(tb))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tv:case tb:return 0;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Primitive({name:t.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Primitive({name:t.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){h.ze(e,tA);let t=o.compareSchema(e,e,tk.schema({names:{requireExplicitPolicy:tv,inhibitPolicyMapping:tb}}));if(S.assertSchema(t,this.className),tv in t.result){let e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"Integer"),this.requireExplicitPolicy=s.result.valueBlock.valueDec}if(tb in t.result){let e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;let a=e.toBER(!1),s=o.fromBER(a);S.assert(s,"Integer"),this.inhibitPolicyMapping=s.result.valueBlock.valueDec}}toSchema(){let e=[];if(tv in this){let t=new o.Integer({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if(tb in this){let t=new o.Integer({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new o.Sequence({value:e})}toJSON(){let e={};return tv in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),tb in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}tk.CLASS_NAME="PolicyConstraints";let tC="issuerDomainPolicy",tN="subjectDomainPolicy",tV=[tC,tN];class tI extends y{constructor(e={}){super(),this.issuerDomainPolicy=h.H$(e,tC,tI.defaultValues(tC)),this.subjectDomainPolicy=h.H$(e,tN,tI.defaultValues(tN)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tC:case tN:return"";default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.issuerDomainPolicy||""}),new o.ObjectIdentifier({name:t.subjectDomainPolicy||""})]})}fromSchema(e){h.ze(e,tV);let t=o.compareSchema(e,e,tI.schema({names:{issuerDomainPolicy:tC,subjectDomainPolicy:tN}}));S.assertSchema(t,this.className),this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.issuerDomainPolicy}),new o.ObjectIdentifier({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}tI.CLASS_NAME="PolicyMapping";let tB="mappings",tE=[tB];class tH extends y{constructor(e={}){super(),this.mappings=h.H$(e,tB,tH.defaultValues(tB)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===tB?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.mappings||"",value:tI.schema()})]})}fromSchema(e){h.ze(e,tE);let t=o.compareSchema(e,e,tH.schema({names:{mappings:tB}}));S.assertSchema(t,this.className),this.mappings=Array.from(t.result.mappings,e=>new tI({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}tH.CLASS_NAME="PolicyMappings";let tD="notBefore",tO="notAfter",tx=[tD,tO];class t$ extends y{constructor(e={}){super(),tD in e&&(this.notBefore=h.H$(e,tD,t$.defaultValues(tD))),tO in e&&(this.notAfter=h.H$(e,tO,t$.defaultValues(tO))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tD:case tO:return new Date;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Primitive({name:t.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new o.Primitive({name:t.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){h.ze(e,tx);let t=o.compareSchema(e,e,t$.schema({names:{notBefore:tD,notAfter:tO}}));if(S.assertSchema(t,this.className),tD in t.result){let e=new o.GeneralizedTime;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if(tO in t.result){let e=new o.GeneralizedTime({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){let e=[];return tD in this&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:new o.GeneralizedTime({valueDate:this.notBefore}).valueBlock.valueHexView})),tO in this&&e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new o.GeneralizedTime({valueDate:this.notAfter}).valueBlock.valueHexView})),new o.Sequence({value:e})}toJSON(){let e={};return this.notBefore&&(e.notBefore=this.notBefore),this.notAfter&&(e.notAfter=this.notAfter),e}}t$.CLASS_NAME="PrivateKeyUsagePeriod";let tP="type",tq="values",tK=["id",tP],tR=[tq];class tJ extends y{constructor(e={}){super(),this.id=h.H$(e,"id",tJ.defaultValues("id")),tP in e&&(this.type=h.H$(e,tP,tJ.defaultValues(tP))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"id":return"";case tP:return new o.Null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"id":return""===t;case tP:return t instanceof o.Null;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||""}),new o.Any({name:t.type||"",optional:!0})]})}fromSchema(e){h.ze(e,tK);let t=o.compareSchema(e,e,tJ.schema({names:{id:"id",type:tP}}));S.assertSchema(t,this.className),this.id=t.result.id.valueBlock.toString(),tP in t.result&&(this.type=t.result.type)}toSchema(){let e=[new o.ObjectIdentifier({value:this.id})];return tP in this&&e.push(this.type),new o.Sequence({value:e})}toJSON(){let e={id:this.id};return this.type&&(e.type=this.type.toJSON()),e}}tJ.CLASS_NAME="QCStatement";class tj extends y{constructor(e={}){super(),this.values=h.H$(e,tq,tj.defaultValues(tq)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===tq?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===tq?0===t.length:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.values||"",value:tJ.schema(t.value||{})})]})}fromSchema(e){h.ze(e,tR);let t=o.compareSchema(e,e,tj.schema({names:{values:tq}}));S.assertSchema(t,this.className),this.values=Array.from(t.result.values,e=>new tJ({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{values:Array.from(this.values,e=>e.toJSON())}}}tj.CLASS_NAME="QCStatements";class tU{static register(e,t,a){this.namedCurves[e.toLowerCase()]=this.namedCurves[t]={name:e,id:t,size:a}}static find(e){return this.namedCurves[e.toLowerCase()]||null}}tU.namedCurves={},tU.register("P-256","1.2.840.10045.3.1.7",32),tU.register("P-384","1.3.132.0.34",48),tU.register("P-521","1.3.132.0.35",66),tU.register("brainpoolP256r1","1.3.36.3.3.2.8.1.1.7",32),tU.register("brainpoolP384r1","1.3.36.3.3.2.8.1.1.11",48),tU.register("brainpoolP512r1","1.3.36.3.3.2.8.1.1.13",64);let tT="namedCurve";class tL extends y{constructor(e={}){super(),this.x=h.H$(e,"x",tL.defaultValues("x")),this.y=h.H$(e,"y",tL.defaultValues("y")),this.namedCurve=h.H$(e,tT,tL.defaultValues(tT)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"x":case"y":return f;case tT:return"";default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return t instanceof ArrayBuffer&&h.dN(t,tL.defaultValues(e));case tT:return"string"==typeof t&&t===tL.defaultValues(e);default:return super.defaultValues(e)}}static schema(){return new o.RawData}fromSchema(e){let t=c.vJ.toUint8Array(e);if(4!==t[0])throw Error("Object's schema was not verified against input data for ECPublicKey");let a=tU.find(this.namedCurve);if(!a)throw Error(`Incorrect curve OID: ${this.namedCurve}`);let s=a.size;if(t.byteLength!==2*s+1)throw Error("Object's schema was not verified against input data for ECPublicKey");this.namedCurve=a.name,this.x=t.slice(1,s+1).buffer,this.y=t.slice(1+s,2*s+1).buffer}toSchema(){return new o.RawData({data:h.hk(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e=tU.find(this.namedCurve);return{crv:e?e.name:this.namedCurve,x:h.s3(h.lE(this.x),!0,!0,!1),y:h.s3(h.lE(this.y),!0,!0,!1)}}fromJSON(e){p.assert("json",e,"crv","x","y");let t=0,a=tU.find(e.crv);a&&(this.namedCurve=a.id,t=a.size);let s=h.gG(h.Gh(e.x,!0));if(s.byteLength<t){this.x=new ArrayBuffer(t);let e=new Uint8Array(this.x),a=new Uint8Array(s);e.set(a,1)}else this.x=s.slice(0,t);let r=h.gG(h.Gh(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);let e=new Uint8Array(this.y),a=new Uint8Array(r);e.set(a,1)}else this.y=r.slice(0,t)}}tL.CLASS_NAME="ECPublicKey";let tM="modulus",t_="publicExponent",tW=[tM,t_];class tz extends y{constructor(e={}){super(),this.modulus=h.H$(e,tM,tz.defaultValues(tM)),this.publicExponent=h.H$(e,t_,tz.defaultValues(t_)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tM:case t_:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.modulus||""}),new o.Integer({name:t.publicExponent||""})]})}fromSchema(e){h.ze(e,tW);let t=o.compareSchema(e,e,tz.schema({names:{modulus:tM,publicExponent:t_}}));S.assertSchema(t,this.className),this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new o.Sequence({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:c.ep.ToBase64Url(this.modulus.valueBlock.valueHexView),e:c.ep.ToBase64Url(this.publicExponent.valueBlock.valueHexView)}}fromJSON(e){p.assert("json",e,"n","e");let t=h.gG(h.Gh(e.n,!0));this.modulus=new o.Integer({valueHex:t.slice(0,Math.pow(2,h.J$(t.byteLength)))}),this.publicExponent=new o.Integer({valueHex:h.gG(h.Gh(e.e,!0)).slice(0,3)})}}tz.CLASS_NAME="RSAPublicKey";let tF="algorithm",tG="subjectPublicKey",tQ=[tF,tG];class tZ extends y{constructor(e={}){super(),this.algorithm=h.H$(e,tF,tZ.defaultValues(tF)),this.subjectPublicKey=h.H$(e,tG,tZ.defaultValues(tG));let t=h.H$(e,"parsedKey",null);t&&(this.parsedKey=t),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}get parsedKey(){if(void 0===this._parsedKey){switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===o.ObjectIdentifier.blockName())try{this._parsedKey=new tL({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHexView})}catch(e){}break;case"1.2.840.113549.1.1.1":{let e=o.fromBER(this.subjectPublicKey.valueBlock.valueHexView);if(-1!==e.offset)try{this._parsedKey=new tz({schema:e.result})}catch(e){}}}this._parsedKey||(this._parsedKey=null)}return this._parsedKey||void 0}set parsedKey(e){this._parsedKey=e}static defaultValues(e){switch(e){case tF:return new T;case tG:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.algorithm||{}),new o.BitString({name:t.subjectPublicKey||""})]})}fromSchema(e){h.ze(e,tQ);let t=o.compareSchema(e,e,tZ.schema({names:{algorithm:{names:{blockName:tF}},subjectPublicKey:tG}}));S.assertSchema(t,this.className),this.algorithm=new T({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey}toSchema(){return new o.Sequence({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if(!this.parsedKey)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};let e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}let t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new tL({json:e}),this.algorithm=new T({algorithmId:"1.2.840.10045.2.1",algorithmParams:new o.ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new tz({json:e}),this.algorithm=new T({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new o.Null});break;default:throw Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new o.BitString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}async importKey(e,t=aM(!0)){try{if(!e)throw Error("Need to provide publicKey input parameter");let a=await t.exportKey("spki",e),s=o.fromBER(a);try{this.fromSchema(s.result)}catch(e){throw Error("Error during initializing object from schema")}}catch(t){let e=t instanceof Error?t.message:`${t}`;throw Error(`Error during exporting public key: ${e}`)}}}tZ.CLASS_NAME="PublicKeyInfo";let tX="version",tY="privateKey",t1="namedCurve",t0="publicKey",t2=[tX,tY,t1,t0];class t3 extends y{constructor(e={}){super(),this.version=h.H$(e,tX,t3.defaultValues(tX)),this.privateKey=h.H$(e,tY,t3.defaultValues(tY)),t1 in e&&(this.namedCurve=h.H$(e,t1,t3.defaultValues(t1))),t0 in e&&(this.publicKey=h.H$(e,t0,t3.defaultValues(t0))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tX:return 1;case tY:return new o.OctetString;case t1:return"";case t0:return new tL;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tX:return t===t3.defaultValues(e);case tY:return t.isEqual(t3.defaultValues(e));case t1:return""===t;case t0:return tL.compareWithDefault(t1,t.namedCurve)&&tL.compareWithDefault("x",t.x)&&tL.compareWithDefault("y",t.y);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.OctetString({name:t.privateKey||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.ObjectIdentifier({name:t.namedCurve||""})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.BitString({name:t.publicKey||""})]})]})}fromSchema(e){h.ze(e,t2);let t=o.compareSchema(e,e,t3.schema({names:{version:tX,privateKey:tY,namedCurve:t1,publicKey:t0}}));if(S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,t1 in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),t0 in t.result){let e={schema:t.result.publicKey.valueBlock.valueHex};t1 in this&&(e.namedCurve=this.namedCurve),this.publicKey=new tL(e)}}toSchema(){let e=[new o.Integer({value:this.version}),this.privateKey];return this.namedCurve&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.ObjectIdentifier({value:this.namedCurve})]})),this.publicKey&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.BitString({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new o.Sequence({value:e})}toJSON(){if(!this.namedCurve||t3.compareWithDefault(t1,this.namedCurve))throw Error('Not enough information for making JSON: absent "namedCurve" value');let e=tU.find(this.namedCurve),t={crv:e?e.name:this.namedCurve,d:c.ep.ToBase64Url(this.privateKey.valueBlock.valueHexView)};if(this.publicKey){let e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){p.assert("json",e,"crv","d");let t=0,a=tU.find(e.crv);a&&(this.namedCurve=a.id,t=a.size);let s=c.ep.FromBase64Url(e.d);if(s.byteLength<t){let e=new ArrayBuffer(t),a=new Uint8Array(e),r=new Uint8Array(s);a.set(r,1),this.privateKey=new o.OctetString({valueHex:e})}else this.privateKey=new o.OctetString({valueHex:s.slice(0,t)});e.x&&e.y&&(this.publicKey=new tL({json:e}))}}t3.CLASS_NAME="ECPrivateKey";let t4="prime",t8="exponent",t5="coefficient",t6=[t4,t8,t5];class t9 extends y{constructor(e={}){super(),this.prime=h.H$(e,t4,t9.defaultValues(t4)),this.exponent=h.H$(e,t8,t9.defaultValues(t8)),this.coefficient=h.H$(e,t5,t9.defaultValues(t5)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case t4:case t8:case t5:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.prime||""}),new o.Integer({name:t.exponent||""}),new o.Integer({name:t.coefficient||""})]})}fromSchema(e){h.ze(e,t6);let t=o.compareSchema(e,e,t9.schema({names:{prime:t4,exponent:t8,coefficient:t5}}));S.assertSchema(t,this.className),this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new o.Sequence({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:c.ep.ToBase64Url(this.prime.valueBlock.valueHexView),d:c.ep.ToBase64Url(this.exponent.valueBlock.valueHexView),t:c.ep.ToBase64Url(this.coefficient.valueBlock.valueHexView)}}fromJSON(e){p.assert("json",e,"r","d","r"),this.prime=new o.Integer({valueHex:c.ep.FromBase64Url(e.r)}),this.exponent=new o.Integer({valueHex:c.ep.FromBase64Url(e.d)}),this.coefficient=new o.Integer({valueHex:c.ep.FromBase64Url(e.t)})}}t9.CLASS_NAME="OtherPrimeInfo";let t7="version",ae="modulus",at="publicExponent",aa="privateExponent",as="prime1",ar="prime2",ai="exponent1",an="exponent2",al="coefficient",au="otherPrimeInfos",ao=[t7,ae,at,aa,as,ar,ai,an,al,au];class ac extends y{constructor(e={}){super(),this.version=h.H$(e,t7,ac.defaultValues(t7)),this.modulus=h.H$(e,ae,ac.defaultValues(ae)),this.publicExponent=h.H$(e,at,ac.defaultValues(at)),this.privateExponent=h.H$(e,aa,ac.defaultValues(aa)),this.prime1=h.H$(e,as,ac.defaultValues(as)),this.prime2=h.H$(e,ar,ac.defaultValues(ar)),this.exponent1=h.H$(e,ai,ac.defaultValues(ai)),this.exponent2=h.H$(e,an,ac.defaultValues(an)),this.coefficient=h.H$(e,al,ac.defaultValues(al)),au in e&&(this.otherPrimeInfos=h.H$(e,au,ac.defaultValues(au))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case t7:return 0;case ae:case at:case aa:case as:case ar:case ai:case an:case al:return new o.Integer;case au:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Integer({name:t.modulus||""}),new o.Integer({name:t.publicExponent||""}),new o.Integer({name:t.privateExponent||""}),new o.Integer({name:t.prime1||""}),new o.Integer({name:t.prime2||""}),new o.Integer({name:t.exponent1||""}),new o.Integer({name:t.exponent2||""}),new o.Integer({name:t.coefficient||""}),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.otherPrimeInfosName||"",value:t9.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){h.ze(e,ao);let t=o.compareSchema(e,e,ac.schema({names:{version:t7,modulus:ae,publicExponent:at,privateExponent:aa,prime1:as,prime2:ar,exponent1:ai,exponent2:an,coefficient:al,otherPrimeInfo:{names:{blockName:au}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),au in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new t9({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),this.otherPrimeInfos&&e.push(new o.Sequence({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={n:c.ep.ToBase64Url(this.modulus.valueBlock.valueHexView),e:c.ep.ToBase64Url(this.publicExponent.valueBlock.valueHexView),d:c.ep.ToBase64Url(this.privateExponent.valueBlock.valueHexView),p:c.ep.ToBase64Url(this.prime1.valueBlock.valueHexView),q:c.ep.ToBase64Url(this.prime2.valueBlock.valueHexView),dp:c.ep.ToBase64Url(this.exponent1.valueBlock.valueHexView),dq:c.ep.ToBase64Url(this.exponent2.valueBlock.valueHexView),qi:c.ep.ToBase64Url(this.coefficient.valueBlock.valueHexView)};return this.otherPrimeInfos&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){p.assert("json",e,"n","e","d","p","q","dp","dq","qi"),this.modulus=new o.Integer({valueHex:c.ep.FromBase64Url(e.n)}),this.publicExponent=new o.Integer({valueHex:c.ep.FromBase64Url(e.e)}),this.privateExponent=new o.Integer({valueHex:c.ep.FromBase64Url(e.d)}),this.prime1=new o.Integer({valueHex:c.ep.FromBase64Url(e.p)}),this.prime2=new o.Integer({valueHex:c.ep.FromBase64Url(e.q)}),this.exponent1=new o.Integer({valueHex:c.ep.FromBase64Url(e.dp)}),this.exponent2=new o.Integer({valueHex:c.ep.FromBase64Url(e.dq)}),this.coefficient=new o.Integer({valueHex:c.ep.FromBase64Url(e.qi)}),e.oth&&(this.otherPrimeInfos=Array.from(e.oth,e=>new t9({json:e})))}}ac.CLASS_NAME="RSAPrivateKey";let ah="version",am="privateKeyAlgorithm",ad="privateKey",af="attributes",ag="parsedKey",ap=[ah,am,ad,af];class aS extends y{constructor(e={}){super(),this.version=h.H$(e,ah,aS.defaultValues(ah)),this.privateKeyAlgorithm=h.H$(e,am,aS.defaultValues(am)),this.privateKey=h.H$(e,ad,aS.defaultValues(ad)),af in e&&(this.attributes=h.H$(e,af,aS.defaultValues(af))),ag in e&&(this.parsedKey=h.H$(e,ag,aS.defaultValues(ag))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ah:return 0;case am:return new T;case ad:return new o.OctetString;case af:return[];case ag:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),T.schema(t.privateKeyAlgorithm||{}),new o.OctetString({name:t.privateKey||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.attributes||"",value:G.schema()})]})]})}fromSchema(e){h.ze(e,ap);let t=o.compareSchema(e,e,aS.schema({names:{version:ah,privateKeyAlgorithm:{names:{blockName:am}},privateKey:ad,attributes:af}}));switch(S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new T({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,af in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new G({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{let e=o.fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new ac({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof o.ObjectIdentifier){let e=o.fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new t3({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){let e=[new o.Integer({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return this.attributes&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){if(!this.parsedKey){let e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return this.attributes&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}let e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}let t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new t3({json:e}),this.privateKeyAlgorithm=new T({algorithmId:"1.2.840.10045.2.1",algorithmParams:new o.ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new ac({json:e}),this.privateKeyAlgorithm=new T({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new o.Null});break;default:throw Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new o.OctetString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}aS.CLASS_NAME="PrivateKeyInfo";let ay="contentType",aw="contentEncryptionAlgorithm",av="encryptedContent",ab=[ay,aw,av];class aA extends y{constructor(e={}){if(super(),this.contentType=h.H$(e,ay,aA.defaultValues(ay)),this.contentEncryptionAlgorithm=h.H$(e,aw,aA.defaultValues(aw)),av in e&&e.encryptedContent&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed&&!e.disableSplit)){let e=new o.OctetString({idBlock:{isConstructed:!0},isConstructed:!0}),t=0,a=this.encryptedContent.valueBlock.valueHexView.slice().buffer,s=a.byteLength;for(;s>0;){let r=new Uint8Array(a,t,t+1024>a.byteLength?a.byteLength-t:1024),i=new ArrayBuffer(r.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=r[e];e.valueBlock.value.push(new o.OctetString({valueHex:i})),s-=r.length,t+=r.length}this.encryptedContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ay:return"";case aw:return new T;case av:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ay:return""===t;case aw:return""===t.algorithmId&&"algorithmParams"in t==!1;case av:return t.isEqual(aA.defaultValues(av));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.contentType||""}),T.schema(t.contentEncryptionAlgorithm||{}),new o.Choice({value:[new o.Constructed({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({value:new o.OctetString})]}),new o.Primitive({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){h.ze(e,ab);let t=o.compareSchema(e,e,aA.schema({names:{contentType:ay,contentEncryptionAlgorithm:{names:{blockName:aw}},encryptedContent:av}}));S.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new T({schema:t.result.contentEncryptionAlgorithm}),av in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){let e={isIndefiniteForm:!1},t=[];if(t.push(new o.ObjectIdentifier({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),this.encryptedContent){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;let a=this.encryptedContent;a.idBlock.tagClass=3,a.idBlock.tagNumber=0,a.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(a)}return new o.Sequence({lenBlock:e,value:t})}toJSON(){let e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return this.encryptedContent&&(e.encryptedContent=this.encryptedContent.toJSON()),e}getEncryptedContent(){if(!this.encryptedContent)throw Error("Parameter 'encryptedContent' is undefined");return o.OctetString.prototype.getValue.call(this.encryptedContent)}}aA.CLASS_NAME="EncryptedContentInfo";let ak="hashAlgorithm",aC="maskGenAlgorithm",aN="saltLength",aV="trailerField",aI=[ak,aC,aN,aV];class aB extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,ak,aB.defaultValues(ak)),this.maskGenAlgorithm=h.H$(e,aC,aB.defaultValues(aC)),this.saltLength=h.H$(e,aN,aB.defaultValues(aN)),this.trailerField=h.H$(e,aV,aB.defaultValues(aV)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ak:return new T({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null});case aC:return new T({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new T({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null}).toSchema()});case aN:return 20;case aV:return 1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[T.schema(t.hashAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[T.schema(t.maskGenAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new o.Integer({name:t.saltLength||""})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new o.Integer({name:t.trailerField||""})]})]})}fromSchema(e){h.ze(e,aI);let t=o.compareSchema(e,e,aB.schema({names:{hashAlgorithm:{names:{blockName:ak}},maskGenAlgorithm:{names:{blockName:aC}},saltLength:aN,trailerField:aV}}));S.assertSchema(t,this.className),ak in t.result&&(this.hashAlgorithm=new T({schema:t.result.hashAlgorithm})),aC in t.result&&(this.maskGenAlgorithm=new T({schema:t.result.maskGenAlgorithm})),aN in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),aV in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){let e=[];return this.hashAlgorithm.isEqual(aB.defaultValues(ak))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(aB.defaultValues(aC))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==aB.defaultValues(aN)&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new o.Integer({value:this.saltLength})]})),this.trailerField!==aB.defaultValues(aV)&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:3},value:[new o.Integer({value:this.trailerField})]})),new o.Sequence({value:e})}toJSON(){let e={};return this.hashAlgorithm.isEqual(aB.defaultValues(ak))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(aB.defaultValues(aC))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==aB.defaultValues(aN)&&(e.saltLength=this.saltLength),this.trailerField!==aB.defaultValues(aV)&&(e.trailerField=this.trailerField),e}}aB.CLASS_NAME="RSASSAPSSParams";let aE="salt",aH="iterationCount",aD="keyLength",aO=[aE,aH,aD,"prf"];class ax extends y{constructor(e={}){super(),this.salt=h.H$(e,aE,ax.defaultValues(aE)),this.iterationCount=h.H$(e,aH,ax.defaultValues(aH)),aD in e&&(this.keyLength=h.H$(e,aD,ax.defaultValues(aD))),"prf"in e&&(this.prf=h.H$(e,"prf",ax.defaultValues("prf"))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case aE:return{};case aH:return -1;case aD:return 0;case"prf":return new T({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null});default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Choice({value:[new o.OctetString({name:t.saltPrimitive||""}),T.schema(t.saltConstructed||{})]}),new o.Integer({name:t.iterationCount||""}),new o.Integer({name:t.keyLength||"",optional:!0}),T.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){h.ze(e,aO);let t=o.compareSchema(e,e,ax.schema({names:{saltPrimitive:aE,saltConstructed:{names:{blockName:aE}},iterationCount:aH,keyLength:aD,prf:{names:{blockName:"prf",optional:!0}}}}));S.assertSchema(t,this.className),this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,aD in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new T({schema:t.result.prf}))}toSchema(){let e=[];return e.push(this.salt),e.push(new o.Integer({value:this.iterationCount})),aD in this&&ax.defaultValues(aD)!==this.keyLength&&e.push(new o.Integer({value:this.keyLength})),this.prf&&!1===ax.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new o.Sequence({value:e})}toJSON(){let e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return aD in this&&ax.defaultValues(aD)!==this.keyLength&&(e.keyLength=this.keyLength),this.prf&&!1===ax.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}ax.CLASS_NAME="PBKDF2Params";let a$="keyDerivationFunc",aP="encryptionScheme",aq=[a$,aP];class aK extends y{constructor(e={}){super(),this.keyDerivationFunc=h.H$(e,a$,aK.defaultValues(a$)),this.encryptionScheme=h.H$(e,aP,aK.defaultValues(aP)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case a$:case aP:return new T;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.keyDerivationFunc||{}),T.schema(t.encryptionScheme||{})]})}fromSchema(e){h.ze(e,aq);let t=o.compareSchema(e,e,aK.schema({names:{keyDerivationFunc:{names:{blockName:a$}},encryptionScheme:{names:{blockName:aP}}}}));S.assertSchema(t,this.className),this.keyDerivationFunc=new T({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new T({schema:t.result.encryptionScheme})}toSchema(){return new o.Sequence({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}aK.CLASS_NAME="PBES2Params";class aR{constructor(e){this.crypto=e.crypto,this.subtle="webkitSubtle"in e.crypto?e.crypto.webkitSubtle:e.crypto.subtle,this.name=h.H$(e,"name","")}async encrypt(...e){return this.subtle.encrypt(...e)}async decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}async verify(...e){return this.subtle.verify(...e)}async digest(...e){return this.subtle.digest(...e)}async generateKey(...e){return this.subtle.generateKey(...e)}async deriveKey(...e){return this.subtle.deriveKey(...e)}async deriveBits(...e){return this.subtle.deriveBits(...e)}async wrapKey(...e){return this.subtle.wrapKey(...e)}async unwrapKey(...e){return this.subtle.unwrapKey(...e)}exportKey(...e){return this.subtle.exportKey(...e)}importKey(...e){return this.subtle.importKey(...e)}getRandomValues(e){return this.crypto.getRandomValues(e)}}async function aJ(e,t,a,s,r,i){let n,l;let u=[];switch(t.toUpperCase()){case"SHA-1":n=20,l=64;break;case"SHA-256":n=32,l=64;break;case"SHA-384":n=48,l=128;break;case"SHA-512":n=64,l=128;break;default:throw Error("Unsupported hashing algorithm")}let o=new Uint8Array(s),c=new ArrayBuffer(2*s.byteLength+2),h=new Uint8Array(c);for(let e=0;e<o.length;e++)h[2*e]=0,h[2*e+1]=o[e];h[h.length-2]=0,h[h.length-1]=0,s=c.slice(0);let m=new ArrayBuffer(l),d=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)d[e]=3;let f=r.byteLength,g=l*Math.ceil(f/l),p=new ArrayBuffer(g),S=new Uint8Array(p),y=new Uint8Array(r);for(let e=0;e<g;e++)S[e]=y[e%f];let w=s.byteLength,v=l*Math.ceil(w/l),b=new ArrayBuffer(v),A=new Uint8Array(b),k=new Uint8Array(s);for(let e=0;e<v;e++)A[e]=k[e%w];let C=p.byteLength+b.byteLength,N=new ArrayBuffer(C),V=new Uint8Array(N);V.set(S),V.set(A,S.length);let I=Math.ceil((a>>3)/n),B=Promise.resolve(N);for(let a=0;a<=I;a++){B=B.then(e=>{let t=new ArrayBuffer(m.byteLength+e.byteLength),a=new Uint8Array(t);return a.set(d),a.set(V,d.length),t});for(let a=0;a<i;a++)B=B.then(a=>e.digest({name:t},new Uint8Array(a)));B=B.then(e=>{let t=new ArrayBuffer(l),a=new Uint8Array(t);for(let s=0;s<t.byteLength;s++)a[s]=e[s%e.byteLength];let s=Math.ceil(f/l)+Math.ceil(w/l),r=[],i=0,n=l;for(let e=0;e<s;e++){let e=Array.from(new Uint8Array(N.slice(i,i+n)));(i+=l)+l>N.byteLength&&(n=N.byteLength-i);let s=511;for(let r=t.byteLength-1;r>=0;r--)s>>=8,s+=a[r]+e[r],e[r]=255&s;r.push(...e)}return N=new ArrayBuffer(r.length),(V=new Uint8Array(N)).set(r),u.push(...new Uint8Array(e)),N})}return B.then(()=>{let e=new ArrayBuffer(a>>3),t=new Uint8Array(e);return t.set(new Uint8Array(u).slice(0,a>>3)),e})}class aj extends aR{async importKey(e,t,a,s,r){var i,n,l,u,m,d;let f={},y=function e(t){let a="string"==typeof t?{name:t}:t;return"hash"in a?{...a,hash:e(a.hash)}:a}(a);switch(e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,a,s,r);case"spki":{let e=o.fromBER(c.vJ.toArrayBuffer(t));S.assert(e,"keyData");let a=new tZ;try{a.fromSchema(e.result)}catch{throw new g("Incorrect keyData")}switch(y.name.toUpperCase()){case"RSA-PSS":if(!y.hash)throw new p("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":f.alg="PS1";break;case"SHA-256":f.alg="PS256";break;case"SHA-384":f.alg="PS384";break;case"SHA-512":f.alg="PS512";break;default:throw Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(r=["verify"],f.kty="RSA",f.ext=s,f.key_ops=r,"1.2.840.113549.1.1.1"!==a.algorithm.algorithmId)throw Error(`Incorrect public key algorithm: ${a.algorithm.algorithmId}`);if(!f.alg){if(!y.hash)throw new p("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":f.alg="RS1";break;case"SHA-256":f.alg="RS256";break;case"SHA-384":f.alg="RS384";break;case"SHA-512":f.alg="RS512";break;default:throw Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}}let e=a.toJSON();Object.assign(f,e)}break;case"ECDSA":r=["verify"];case"ECDH":{if(f={kty:"EC",ext:s,key_ops:r},"1.2.840.10045.2.1"!==a.algorithm.algorithmId)throw Error(`Incorrect public key algorithm: ${a.algorithm.algorithmId}`);let e=a.toJSON();Object.assign(f,e)}break;case"RSA-OAEP":{if(f.kty="RSA",f.ext=s,f.key_ops=r,"safari"===this.name.toLowerCase())f.alg="RSA-OAEP";else{if(!y.hash)throw new p("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(y.hash.name.toUpperCase()){case"SHA-1":f.alg="RSA-OAEP";break;case"SHA-256":f.alg="RSA-OAEP-256";break;case"SHA-384":f.alg="RSA-OAEP-384";break;case"SHA-512":f.alg="RSA-OAEP-512";break;default:throw Error(`Incorrect hash algorithm: ${y.hash.name.toUpperCase()}`)}}let e=a.toJSON();Object.assign(f,e)}break;case"RSAES-PKCS1-V1_5":{f.kty="RSA",f.ext=s,f.key_ops=r,f.alg="PS1";let e=a.toJSON();Object.assign(f,e)}break;default:throw Error(`Incorrect algorithm name: ${y.name.toUpperCase()}`)}}break;case"pkcs8":{let e=new aS,a=o.fromBER(c.vJ.toArrayBuffer(t));S.assert(a,"keyData");try{e.fromSchema(a.result)}catch(e){throw Error("Incorrect keyData")}if(!e.parsedKey)throw Error("Incorrect keyData");switch(y.name.toUpperCase()){case"RSA-PSS":switch(null===(i=y.hash)||void 0===i?void 0:i.name.toUpperCase()){case"SHA-1":f.alg="PS1";break;case"SHA-256":f.alg="PS256";break;case"SHA-384":f.alg="PS384";break;case"SHA-512":f.alg="PS512";break;default:throw Error(`Incorrect hash algorithm: ${null===(n=y.hash)||void 0===n?void 0:n.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(r=["sign"],f.kty="RSA",f.ext=s,f.key_ops=r,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)throw Error(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in f==!1)switch(null===(l=y.hash)||void 0===l?void 0:l.name.toUpperCase()){case"SHA-1":f.alg="RS1";break;case"SHA-256":f.alg="RS256";break;case"SHA-384":f.alg="RS384";break;case"SHA-512":f.alg="RS512";break;default:throw Error(`Incorrect hash algorithm: ${null===(u=y.hash)||void 0===u?void 0:u.name.toUpperCase()}`)}let t=e.toJSON();Object.assign(f,t)}break;case"ECDSA":r=["sign"];case"ECDH":{if(f={kty:"EC",ext:s,key_ops:r},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)throw Error(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);let t=e.toJSON();Object.assign(f,t)}break;case"RSA-OAEP":{if(f.kty="RSA",f.ext=s,f.key_ops=r,"safari"===this.name.toLowerCase())f.alg="RSA-OAEP";else switch(null===(m=y.hash)||void 0===m?void 0:m.name.toUpperCase()){case"SHA-1":f.alg="RSA-OAEP";break;case"SHA-256":f.alg="RSA-OAEP-256";break;case"SHA-384":f.alg="RSA-OAEP-384";break;case"SHA-512":f.alg="RSA-OAEP-512";break;default:throw Error(`Incorrect hash algorithm: ${null===(d=y.hash)||void 0===d?void 0:d.name.toUpperCase()}`)}let t=e.toJSON();Object.assign(f,t)}break;case"RSAES-PKCS1-V1_5":{r=["decrypt"],f.kty="RSA",f.ext=s,f.key_ops=r,f.alg="PS1";let t=e.toJSON();Object.assign(f,t)}break;default:throw Error(`Incorrect algorithm name: ${y.name.toUpperCase()}`)}}break;case"jwk":f=t;break;default:throw Error(`Incorrect format: ${e}`)}if("safari"===this.name.toLowerCase())try{return this.subtle.importKey("jwk",h.gG(JSON.stringify(f)),a,s,r)}catch{}return this.subtle.importKey("jwk",f,a,s,r)}async exportKey(e,t){let a=await this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&a instanceof ArrayBuffer&&(a=JSON.parse(h.lE(a))),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":{let e=new tZ;try{e.fromJSON(a)}catch(e){throw Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"pkcs8":{let e=new aS;try{e.fromJSON(a)}catch(e){throw Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"jwk":return a;default:throw Error(`Incorrect format: ${e}`)}}async convert(e,t,a,s,r,i){if(e.toLowerCase()===t.toLowerCase())return a;let n=await this.importKey(e,a,s,r,i);return this.exportKey(t,n)}getAlgorithmByOID(e,t=!1,a){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}if(t)throw Error(`Unsupported algorithm identifier ${a?`for ${a} `:""}: ${e}`);return{}}getOIDByAlgorithm(e,t=!1,a){let s="";switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":s="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.1.1.5";break;case"SHA-256":s="1.2.840.113549.1.1.11";break;case"SHA-384":s="1.2.840.113549.1.1.12";break;case"SHA-512":s="1.2.840.113549.1.1.13"}break;case"RSA-PSS":s="1.2.840.113549.1.1.10";break;case"RSA-OAEP":s="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.10045.4.1";break;case"SHA-256":s="1.2.840.10045.4.3.2";break;case"SHA-384":s="1.2.840.10045.4.3.3";break;case"SHA-512":s="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":s="1.3.133.16.840.63.0.2";break;case"SHA-256":s="1.3.132.1.11.1";break;case"SHA-384":s="1.3.132.1.11.2";break;case"SHA-512":s="1.3.132.1.11.3"}break;case"AES-CTR":case"AES-CMAC":case"CONCAT":case"HKDF":break;case"AES-CBC":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.2";break;case 192:s="2.16.840.1.101.3.4.1.22";break;case 256:s="2.16.840.1.101.3.4.1.42"}break;case"AES-GCM":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.6";break;case 192:s="2.16.840.1.101.3.4.1.26";break;case 256:s="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.4";break;case 192:s="2.16.840.1.101.3.4.1.24";break;case 256:s="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.5";break;case 192:s="2.16.840.1.101.3.4.1.25";break;case 256:s="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.2.7";break;case"SHA-256":s="1.2.840.113549.2.9";break;case"SHA-384":s="1.2.840.113549.2.10";break;case"SHA-512":s="1.2.840.113549.2.11"}break;case"DH":s="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":s="1.3.14.3.2.26";break;case"SHA-256":s="2.16.840.1.101.3.4.2.1";break;case"SHA-384":s="2.16.840.1.101.3.4.2.2";break;case"SHA-512":s="2.16.840.1.101.3.4.2.3";break;case"PBKDF2":s="1.2.840.113549.1.5.12";break;case"P-256":s="1.2.840.10045.3.1.7";break;case"P-384":s="1.3.132.0.34";break;case"P-521":s="1.3.132.0.35"}if(!s&&t)throw Error(`Unsupported algorithm ${a?`for ${a} `:""}: ${e.name}`);return s}getAlgorithmParameters(e,t){let a={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":a={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":a={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":a={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":a={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":a={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":a={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":a={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":a={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":a={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":a={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":a={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":a={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":a={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":a={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":a={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":a={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":a={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":a={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":a={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"HKDF"},usages:[]};a={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;case"PBKDF2":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"PBKDF2"},usages:[]};a={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]}}return a}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{let a=new aB({schema:e.algorithmParams});if(a.hashAlgorithm){let e=this.getAlgorithmByOID(a.hashAlgorithm.algorithmId);if(!("name"in e))return"";t=e.name}else t="SHA-1"}catch{}}return t}async encryptEncryptedContentInfo(e){p.assert(e,"password","contentEncryptionAlgorithm","hmacHashAlgorithm","iterationCount","contentToEncrypt","contentToEncrypt","contentType");let t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm,!0,"contentEncryptionAlgorithm"),a=this.getOIDByAlgorithm({name:"PBKDF2"},!0,"PBKDF2"),s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),r=new ArrayBuffer(16),i=new Uint8Array(r);this.getRandomValues(i);let n=new ArrayBuffer(64),l=new Uint8Array(n);this.getRandomValues(l);let u=new Uint8Array(e.contentToEncrypt),c=new ax({salt:new o.OctetString({valueHex:n}),iterationCount:e.iterationCount,prf:new T({algorithmId:s,algorithmParams:new o.Null})}),h=new Uint8Array(e.password),m=await this.importKey("raw",h,"PBKDF2",!1,["deriveKey"]),d=await this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},m,e.contentEncryptionAlgorithm,!1,["encrypt"]),f=await this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},d,u),g=new aK({keyDerivationFunc:new T({algorithmId:a,algorithmParams:c.toSchema()}),encryptionScheme:new T({algorithmId:t,algorithmParams:new o.OctetString({valueHex:r})})});return new aA({contentType:e.contentType,contentEncryptionAlgorithm:new T({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:g.toSchema()}),encryptedContent:new o.OctetString({valueHex:f})})}async decryptEncryptedContentInfo(e){let t,a;if(p.assert(e,"password","encryptedContentInfo"),"1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)throw Error(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);try{t=new aK({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){throw Error('Incorrectly encoded "pbes2Parameters"')}try{a=new ax({schema:t.keyDerivationFunc.algorithmParams})}catch(e){throw Error('Incorrectly encoded "pbkdf2Params"')}let s=this.getAlgorithmByOID(t.encryptionScheme.algorithmId,!0),r=t.encryptionScheme.algorithmParams.valueBlock.valueHex,i=new Uint8Array(r),n=a.salt.valueBlock.valueHex,l=new Uint8Array(n),u=a.iterationCount,o="SHA-1";if(a.prf){let e=this.getAlgorithmByOID(a.prf.algorithmId,!0);o=e.hash.name}let c=await this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),h=await this.deriveKey({name:"PBKDF2",hash:{name:o},salt:l,iterations:u},c,s,!1,["decrypt"]),m=e.encryptedContentInfo.getEncryptedContent();return this.decrypt({name:s.name,iv:i},h,m)}async stampDataWithPassword(e){let t;if(e instanceof Object==!1)throw Error('Parameters must have type "Object"');switch(p.assert(e,"password","hashAlgorithm","iterationCount","salt","contentToStamp"),e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let a={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await aJ(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),r=await this.importKey("raw",new Uint8Array(s),a,!1,["sign"]);return this.sign(a,r,new Uint8Array(e.contentToStamp))}async verifyDataStampedWithPassword(e){p.assert(e,"password","hashAlgorithm","salt","iterationCount","contentToVerify","signatureToVerify");let t=0;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let a={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await aJ(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),r=await this.importKey("raw",new Uint8Array(s),a,!1,["verify"]);return this.verify(a,r,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify))}async getSignatureParameters(e,t="SHA-1"){this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");let a=new T,s=this.getAlgorithmParameters(e.algorithm.name,"sign");if(!Object.keys(s.algorithm).length)throw Error("Parameter 'algorithm' is empty");let r=s.algorithm;switch(r.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":a.algorithmId=this.getOIDByAlgorithm(r,!0);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":r.saltLength=32;break;case"SHA-384":r.saltLength=48;break;case"SHA-512":r.saltLength=64}let e={};if("SHA-1"!==t.toUpperCase()){let a=this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");e.hashAlgorithm=new T({algorithmId:a,algorithmParams:new o.Null}),e.maskGenAlgorithm=new T({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==r.saltLength&&(e.saltLength=r.saltLength);let s=new aB(e);a.algorithmId="1.2.840.113549.1.1.10",a.algorithmParams=s.toSchema()}break;default:throw Error(`Unsupported signature algorithm: ${e.algorithm.name}`)}return{signatureAlgorithm:a,parameters:s}}async signWithPrivateKey(e,t,a){let s=await this.sign(a.algorithm,t,e);return"ECDSA"===a.algorithm.name?function(e){if(e.byteLength%2!=0)return f;let t=e.byteLength/2,a=new ArrayBuffer(t),s=new Uint8Array(a);s.set(new Uint8Array(e,0,t));let r=new o.Integer({valueHex:a}),i=new ArrayBuffer(t),n=new Uint8Array(i);n.set(new Uint8Array(e,t,t));let l=new o.Integer({valueHex:i});return new o.Sequence({value:[r.convertToDER(),l.convertToDER()]}).toBER(!1)}(s):s}fillPublicKeyParameters(e,t){let a;let s={},r=this.getHashAlgorithm(t);if(""===r)throw Error(`Unsupported signature algorithm: ${t.algorithmId}`);a="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;let i=this.getAlgorithmByOID(a,!0);if(s.algorithm=this.getAlgorithmParameters(i.name,"importKey"),"hash"in s.algorithm.algorithm&&(s.algorithm.algorithm.hash.name=r),"ECDSA"===i.name){let t=e.algorithm;if(!t.algorithmParams)throw Error("Algorithm parameters for ECDSA public key are missed");let a=t.algorithmParams;if("idBlock"in t.algorithmParams&&!(1===a.idBlock.tagClass&&6===a.idBlock.tagNumber))throw Error("Incorrect type for ECDSA public key parameters");let r=this.getAlgorithmByOID(a.valueBlock.toString(),!0);s.algorithm.algorithm.namedCurve=r.name}return s}async getPublicKey(e,t,a){a||(a=this.fillPublicKeyParameters(e,t));let s=e.toSchema().toBER(!1);return this.importKey("spki",s,a.algorithm.algorithm,!0,a.algorithm.usages)}async verifyWithPublicKey(e,t,a,s,r){let i;if(r){let e;let t={};e="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:a.algorithm.algorithmId;let n=this.getAlgorithmByOID(e,!0);if(t.algorithm=this.getAlgorithmParameters(n.name,"importKey"),"hash"in t.algorithm.algorithm&&(t.algorithm.algorithm.hash.name=r),"ECDSA"===n.name){let e=!1;if("algorithmParams"in a.algorithm==!0&&"idBlock"in a.algorithm.algorithmParams&&1===a.algorithm.algorithmParams.idBlock.tagClass&&6===a.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)throw Error("Incorrect type for ECDSA public key parameters");let s=this.getAlgorithmByOID(a.algorithm.algorithmParams.valueBlock.toString(),!0);t.algorithm.algorithm.namedCurve=s.name}i=await this.getPublicKey(a,null,t)}else{if(!(r=this.getHashAlgorithm(s)))throw Error(`Unsupported signature algorithm: ${s.algorithmId}`);i=await this.getPublicKey(a,s)}let n=this.getAlgorithmParameters(i.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=r);let l=t.valueBlock.valueHexView;if("ECDSA"===i.algorithm.name){let e=tU.find(i.algorithm.namedCurve);if(!e)throw Error("Unsupported named curve in use");let t=o.fromBER(l);S.assert(t,"Signature value"),l=function(e,t){if(!(e instanceof o.Sequence&&2===e.valueBlock.value.length&&e.valueBlock.value[0]instanceof o.Integer&&e.valueBlock.value[1]instanceof o.Integer))return f;let a=e.valueBlock.value[0].convertFromDER().valueBlock.valueHexView,s=e.valueBlock.value[1].convertFromDER().valueBlock.valueHexView,r=new Uint8Array(2*t);return r.set(a,t-a.byteLength),r.set(s,2*t-s.byteLength),r.buffer}(t.result,e.size)}if("RSA-PSS"===i.algorithm.name){let e=new aB({schema:s.algorithmParams});"saltLength"in e?n.algorithm.saltLength=e.saltLength:n.algorithm.saltLength=20;let t="SHA-1";if("hashAlgorithm"in e){let a=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId,!0);t=a.name}n.algorithm.hash.name=t}return this.verify(n.algorithm,i,l,e)}}let aU={name:"none",crypto:null};function aT(e){return!!e&&"object"==typeof e&&"crypto"in e}function aL(e,...t){let s=null;if(t.length<2)s=t.length?t[0]:"undefined"!=typeof self&&self.crypto?new aj({name:"browser",crypto:self.crypto}):null;else{let e=t[0],a=t[1];aT(a)?s=a:aT(e)?s=e:"subtle"in e&&"getRandomValues"in e&&(s=new aj({crypto:e}))}if(void 0!==d&&"pid"in d&&void 0!==a.g&&"undefined"==typeof window){if(void 0===a.g[d.pid])a.g[d.pid]={};else if("object"!=typeof a.g[d.pid])throw Error(`Name global.${d.pid} already exists and it is not an object`);if(void 0===a.g[d.pid].pkijs)a.g[d.pid].pkijs={};else if("object"!=typeof a.g[d.pid].pkijs)throw Error(`Name global.${d.pid}.pkijs already exists and it is not an object`);a.g[d.pid].pkijs.engine={name:e,crypto:s}}else aU={name:e,crypto:s}}function aM(e=!1){let t=function(){if(void 0!==d&&"pid"in d&&void 0!==a.g&&"undefined"==typeof window){let e;try{e=a.g[d.pid].pkijs.engine}catch(e){throw Error("Please call 'setEngine' before call to 'getEngine'")}return e}return aU}();if(!t.crypto&&e)throw Error("Unable to create WebCrypto object");return t.crypto}async function a_(e,t,a,s,r){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:throw new g(`Unknown hash function: ${e}`)}if(g.assert(t,"zBuffer","ArrayBuffer"),0===t.byteLength)throw new g("'zBuffer' has zero length, error");if(g.assert(s,"SharedInfo","ArrayBuffer"),a>255)throw new g("Please set 'Counter' argument to value less or equal to 255");let i=new ArrayBuffer(4),n=new Uint8Array(i);n[0]=0,n[1]=0,n[2]=0,n[3]=a;let l=f;l=h.hk(l,t),l=h.hk(l,i),l=h.hk(l,s);let u=await r.digest({name:e},l);return{counter:a,result:u}}async function aW(e,t,a,s,r=aM(!0)){let i=0,n=1;switch(e.toUpperCase()){case"SHA-1":i=160;break;case"SHA-256":i=256;break;case"SHA-384":i=384;break;case"SHA-512":i=512;break;default:throw new g(`Unknown hash function: ${e}`)}if(g.assert(t,"Zbuffer","ArrayBuffer"),0===t.byteLength)throw new g("'Zbuffer' has zero length, error");g.assert(s,"SharedInfo","ArrayBuffer");let l=a/i;Math.floor(l)>0&&(n=Math.floor(l),l-n>0&&n++);let u=[];for(let a=1;a<=n;a++)u.push(await a_(e,t,a,s,r));let o=f,c=1,m=!0;for(;m;){for(let e of(m=!1,u))if(e.counter===c){o=h.hk(o,e.result),m=!0;break}c++}if(a>>=3,o.byteLength>a){let e=new ArrayBuffer(a),t=new Uint8Array(e),s=new Uint8Array(o);for(let e=0;e<a;e++)t[e]=s[e];return e}return o}let az="version",aF="logID",aG="extensions",aQ="timestamp",aZ="hashAlgorithm",aX="signatureAlgorithm",aY="signature",a1="none",a0="sha1",a2="sha224",a3="sha256",a4="sha384",a8="sha512",a5="anonymous",a6="ecdsa";class a9 extends y{constructor(e={}){super(),this.version=h.H$(e,az,a9.defaultValues(az)),this.logID=h.H$(e,aF,a9.defaultValues(aF)),this.timestamp=h.H$(e,aQ,a9.defaultValues(aQ)),this.extensions=h.H$(e,aG,a9.defaultValues(aG)),this.hashAlgorithm=h.H$(e,aZ,a9.defaultValues(aZ)),this.signatureAlgorithm=h.H$(e,aX,a9.defaultValues(aX)),this.signature=h.H$(e,aY,a9.defaultValues(aY)),"stream"in e&&e.stream&&this.fromStream(e.stream),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case az:return 0;case aF:case aG:return f;case aQ:return new Date(0);case aZ:case aX:return"";case aY:return new o.Any;default:return super.defaultValues(e)}}fromSchema(e){if(e instanceof o.RawData==!1)throw Error("Object's schema was not verified against input data for SignedCertificateTimestamp");let t=new m.sF({stream:new m.$W({buffer:e.data})});this.fromStream(t)}fromStream(e){let t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(h.r9(new Uint8Array(e.getBlock(8)),8));let a=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(a)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm=a1;break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm=a0;break;case 3:this.hashAlgorithm=a2;break;case 4:this.hashAlgorithm=a3;break;case 5:this.hashAlgorithm=a4;break;case 6:this.hashAlgorithm=a8;break;default:throw Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm=a5;break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm=a6;break;default:throw Error("Object's stream was not correct for SignedCertificateTimestamp")}let s=e.getUint16(),r=new Uint8Array(e.getBlock(s)).buffer.slice(0),i=o.fromBER(r);if(S.assert(i,"SignedCertificateTimestamp"),this.signature=i.result,t!==47+a+s)throw Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){let e=this.toStream();return new o.RawData({data:e.stream.buffer})}toStream(){let e,t;let a=new m.sF;a.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecodeView.byteLength),a.appendChar(this.version),a.appendView(new Uint8Array(this.logID));let s=new ArrayBuffer(8),r=new Uint8Array(s),i=h.lL(this.timestamp.valueOf(),8);switch(r.set(new Uint8Array(i),8-i.byteLength),a.appendView(r),a.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&a.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case a1:e=0;break;case"md5":e=1;break;case a0:e=2;break;case a2:e=3;break;case a3:e=4;break;case a4:e=5;break;case a8:e=6;break;default:throw Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(a.appendChar(e),this.signatureAlgorithm.toLowerCase()){case a5:t=0;break;case"rsa":t=1;break;case"dsa":t=2;break;case a6:t=3;break;default:throw Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}a.appendChar(t);let n=this.signature.toBER(!1);return a.appendUint16(n.byteLength),a.appendView(new Uint8Array(n)),a}toJSON(){return{version:this.version,logID:h.RH(this.logID),timestamp:this.timestamp,extensions:h.RH(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,a=0,s=aM(!0)){let r=h.s3(h.lE(this.logID)),i=null,n=new m.sF;for(let t of e)if(t.log_id===r){i=t.key;break}if(!i)throw Error(`Public key not found for CT with logId: ${r}`);let l=h.gG(h.Gh(i)),u=tZ.fromBER(l);n.appendChar(0),n.appendChar(0);let c=new ArrayBuffer(8),d=new Uint8Array(c),f=h.lL(this.timestamp.valueOf(),8);return d.set(new Uint8Array(f),8-f.byteLength),n.appendView(d),n.appendUint16(a),0===a&&n.appendUint24(t.byteLength),n.appendView(new Uint8Array(t)),n.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&n.appendView(new Uint8Array(this.extensions)),s.verifyWithPublicKey(n.buffer.slice(0,n.length),new o.OctetString({valueHex:this.signature.toBER(!1)}),u,{algorithmId:""},"SHA-256")}}a9.CLASS_NAME="SignedCertificateTimestamp";let a7="timestamps";class se extends y{constructor(e={}){super(),this.timestamps=h.H$(e,a7,se.defaultValues(a7)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===a7?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===a7?0===t.length:super.defaultValues(e)}static schema(e={}){var t;let a=h.H$(e,"names",{});return null!==(t=a.optional)&&void 0!==t||(a.optional=!1),new o.OctetString({name:a.blockName||"SignedCertificateTimestampList",optional:a.optional})}fromSchema(e){if(e instanceof o.OctetString==!1)throw Error("Object's schema was not verified against input data for SignedCertificateTimestampList");let t=new m.sF({stream:new m.$W({buffer:e.valueBlock.valueHex})}),a=t.getUint16();if(a!==t.length)throw Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new a9({stream:t}))}toSchema(){let e=new m.sF,t=0,a=[];for(let e of this.timestamps){let s=e.toStream();a.push(s),t+=s.stream.buffer.byteLength}for(let s of(e.appendUint16(t),a))e.appendView(s.stream.view);return new o.OctetString({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}se.CLASS_NAME="SignedCertificateTimestampList";let st="attributes",sa=[st];class ss extends y{constructor(e={}){super(),this.attributes=h.H$(e,st,ss.defaultValues(st)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===st?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.attributes||"",value:G.schema()})]})}fromSchema(e){h.ze(e,sa);let t=o.compareSchema(e,e,ss.schema({names:{attributes:st}}));S.assertSchema(t,this.className),this.attributes=Array.from(t.result.attributes,e=>new G({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}ss.CLASS_NAME="SubjectDirectoryAttributes";class sr{static getItems(){return this.types||(this.types={},sr.register(es,"SubjectAltName",_),sr.register(er,"IssuerAltName",_),sr.register(ef,"AuthorityKeyIdentifier",eE),sr.register(ei,"BasicConstraints",eD),sr.register("1.3.6.1.4.1.311.21.1","MicrosoftCaVersion",e$),sr.register(eh,"CertificatePolicies",e_),sr.register("1.3.6.1.4.1.311.21.10","CertificatePoliciesMicrosoft",e_),sr.register("1.3.6.1.4.1.311.21.7","MicrosoftCertTemplateV2",eQ),sr.register(eo,"CRLDistributionPoints",e5),sr.register(ec,"FreshestCRL",e5),sr.register("2.5.29.37","ExtKeyUsage",e7),sr.register(el,"CertificateIssuer",ea),sr.register(ep,"AuthorityInfoAccess",tt),sr.register("1.3.6.1.5.5.7.1.11","SubjectInfoAccess",tt),sr.register(en,"IssuingDistributionPoint",tc),sr.register(eu,"NameConstraints",tw),sr.register(eg,"PolicyConstraints",tk),sr.register(ed,"PolicyMappings",tH),sr.register("2.5.29.16","PrivateKeyUsagePeriod",t$),sr.register("1.3.6.1.5.5.7.1.3","QCStatements",tj),sr.register("1.3.6.1.4.1.11129.2.4.2","SignedCertificateTimestampList",se),sr.register("2.5.29.9","SubjectDirectoryAttributes",ss)),this.types}static fromBER(e,t){let a=o.fromBER(t);if(-1===a.offset)return null;let s=this.find(e);if(s)try{return new s.type({schema:a.result})}catch(a){let t=new s.type;return t.parsingError=`Incorrectly formatted value of extension ${s.name} (${e})`,t}return a.result}static find(e){let t=this.getItems();return t[e]||null}static register(e,t,a){this.getItems()[e]={name:t,type:a}}}let si="extnID",sn="critical",sl="extnValue",su="parsedValue",so=[si,sn,sl];class sc extends y{constructor(e={}){super(),this.extnID=h.H$(e,si,sc.defaultValues(si)),this.critical=h.H$(e,sn,sc.defaultValues(sn)),sl in e?this.extnValue=new o.OctetString({valueHex:e.extnValue}):this.extnValue=sc.defaultValues(sl),su in e&&(this.parsedValue=h.H$(e,su,sc.defaultValues(su))),e.schema&&this.fromSchema(e.schema)}get parsedValue(){if(void 0===this._parsedValue){let e=sr.fromBER(this.extnID,this.extnValue.valueBlock.valueHexView);this._parsedValue=e}return this._parsedValue||void 0}set parsedValue(e){this._parsedValue=e}static defaultValues(e){switch(e){case si:return"";case sn:return!1;case sl:return new o.OctetString;case su:return{};default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.extnID||""}),new o.Boolean({name:t.critical||"",optional:!0}),new o.OctetString({name:t.extnValue||""})]})}fromSchema(e){h.ze(e,so);let t=o.compareSchema(e,e,sc.schema({names:{extnID:si,critical:sn,extnValue:sl}}));S.assertSchema(t,this.className),this.extnID=t.result.extnID.valueBlock.toString(),sn in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.extnID})),this.critical!==sc.defaultValues(sn)&&e.push(new o.Boolean({value:this.critical})),e.push(this.extnValue),new o.Sequence({value:e})}toJSON(){let e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==sc.defaultValues(sn)&&(e.critical=this.critical),this.parsedValue&&this.parsedValue.toJSON&&(e.parsedValue=this.parsedValue.toJSON()),e}}sc.CLASS_NAME="Extension";let sh="extensions",sm=[sh];class sd extends y{constructor(e={}){super(),this.extensions=h.H$(e,sh,sd.defaultValues(sh)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===sh?[]:super.defaultValues(e)}static schema(e={},t=!1){let a=h.H$(e,"names",{});return new o.Sequence({optional:t,name:a.blockName||"",value:[new o.Repeated({name:a.extensions||"",value:sc.schema(a.extension||{})})]})}fromSchema(e){h.ze(e,sm);let t=o.compareSchema(e,e,sd.schema({names:{extensions:sh}}));S.assertSchema(t,this.className),this.extensions=Array.from(t.result.extensions,e=>new sc({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:this.extensions.map(e=>e.toJSON())}}}sd.CLASS_NAME="Extensions";let sf="issuer",sg="serialNumber",sp="issuerUID",sS=[sf,sg,sp];class sy extends y{constructor(e={}){super(),this.issuer=h.H$(e,sf,sy.defaultValues(sf)),this.serialNumber=h.H$(e,sg,sy.defaultValues(sg)),sp in e&&(this.issuerUID=h.H$(e,sp,sy.defaultValues(sp))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sf:return new ea;case sg:return new o.Integer;case sp:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[ea.schema(t.issuer||{}),new o.Integer({name:t.serialNumber||""}),new o.BitString({optional:!0,name:t.issuerUID||""})]})}fromSchema(e){h.ze(e,sS);let t=o.compareSchema(e,e,sy.schema({names:{issuer:{names:{blockName:sf}},serialNumber:sg,issuerUID:sp}}));S.assertSchema(t,this.className),this.issuer=new ea({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,sp in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){let e=new o.Sequence({value:[this.issuer.toSchema(),this.serialNumber]});return this.issuerUID&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){let e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return this.issuerUID&&(e.issuerUID=this.issuerUID.toJSON()),e}}sy.CLASS_NAME="IssuerSerial";let sw="version",sv="baseCertificateID",sb="subjectName",sA="issuer",sk="signature",sC="serialNumber",sN="attrCertValidityPeriod",sV="attributes",sI="issuerUniqueID",sB="extensions",sE=[sw,sv,sb,sA,sk,sC,sN,sV,sI,sB];class sH extends y{constructor(e={}){super(),this.version=h.H$(e,sw,sH.defaultValues(sw)),sv in e&&(this.baseCertificateID=h.H$(e,sv,sH.defaultValues(sv))),sb in e&&(this.subjectName=h.H$(e,sb,sH.defaultValues(sb))),this.issuer=h.H$(e,sA,sH.defaultValues(sA)),this.signature=h.H$(e,sk,sH.defaultValues(sk)),this.serialNumber=h.H$(e,sC,sH.defaultValues(sC)),this.attrCertValidityPeriod=h.H$(e,sN,sH.defaultValues(sN)),this.attributes=h.H$(e,sV,sH.defaultValues(sV)),sI in e&&(this.issuerUniqueID=h.H$(e,sI,sH.defaultValues(sI))),sB in e&&(this.extensions=h.H$(e,sB,sH.defaultValues(sB))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sw:return 0;case sv:return new sy;case sb:case sA:return new ea;case sk:return new T;case sC:return new o.Integer;case sN:return new Y;case sV:return[];case sI:return new o.BitString;case sB:return new sd;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Choice({value:[new o.Constructed({name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:sy.schema().valueBlock.value}),new o.Constructed({name:t.subjectName||"",idBlock:{tagClass:3,tagNumber:1},value:ea.schema().valueBlock.value})]}),ea.schema({names:{blockName:t.issuer||""}}),T.schema(t.signature||{}),new o.Integer({name:t.serialNumber||""}),Y.schema(t.attrCertValidityPeriod||{}),new o.Sequence({name:t.attributes||"",value:[new o.Repeated({value:G.schema()})]}),new o.BitString({optional:!0,name:t.issuerUniqueID||""}),sd.schema(t.extensions||{},!0)]})}fromSchema(e){h.ze(e,sE);let t=o.compareSchema(e,e,sH.schema({names:{version:sw,baseCertificateID:sv,subjectName:sb,issuer:sA,signature:{names:{blockName:sk}},serialNumber:sC,attrCertValidityPeriod:{names:{blockName:sN}},attributes:sV,issuerUniqueID:sI,extensions:{names:{blockName:sB}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,sv in t.result&&(this.baseCertificateID=new sy({schema:new o.Sequence({value:t.result.baseCertificateID.valueBlock.value})})),sb in t.result&&(this.subjectName=new ea({schema:new o.Sequence({value:t.result.subjectName.valueBlock.value})})),this.issuer=t.result.issuer,this.signature=new T({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new Y({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new G({schema:e})),sI in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),sB in t.result&&(this.extensions=new sd({schema:t.result.extensions}))}toSchema(){let e=new o.Sequence({value:[new o.Integer({value:this.version})]});return this.baseCertificateID&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.subjectName&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.subjectName.toSchema().valueBlock.value})),e.valueBlock.value.push(this.issuer.toSchema()),e.valueBlock.value.push(this.signature.toSchema()),e.valueBlock.value.push(this.serialNumber),e.valueBlock.value.push(this.attrCertValidityPeriod.toSchema()),e.valueBlock.value.push(new o.Sequence({value:Array.from(this.attributes,e=>e.toSchema())})),this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){let e={version:this.version};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.subjectName&&(e.subjectName=this.subjectName.toJSON()),e.issuer=this.issuer.toJSON(),e.signature=this.signature.toJSON(),e.serialNumber=this.serialNumber.toJSON(),e.attrCertValidityPeriod=this.attrCertValidityPeriod.toJSON(),e.attributes=Array.from(this.attributes,e=>e.toJSON()),this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}sH.CLASS_NAME="AttributeCertificateInfoV1";let sD="acinfo",sO="signatureAlgorithm",sx="signatureValue",s$=[sD,sx,sO];class sP extends y{constructor(e={}){super(),this.acinfo=h.H$(e,sD,sP.defaultValues(sD)),this.signatureAlgorithm=h.H$(e,sO,sP.defaultValues(sO)),this.signatureValue=h.H$(e,sx,sP.defaultValues(sx)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sD:return new sH;case sO:return new T;case sx:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[sH.schema(t.acinfo||{}),T.schema(t.signatureAlgorithm||{}),new o.BitString({name:t.signatureValue||""})]})}fromSchema(e){h.ze(e,s$);let t=o.compareSchema(e,e,sP.schema({names:{acinfo:{names:{blockName:sD}},signatureAlgorithm:{names:{blockName:sO}},signatureValue:sx}}));S.assertSchema(t,this.className),this.acinfo=new sH({schema:t.result.acinfo}),this.signatureAlgorithm=new T({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new o.Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}sP.CLASS_NAME="AttributeCertificateV1";let sq="digestedObjectType",sK="otherObjectTypeID",sR="digestAlgorithm",sJ="objectDigest",sj=[sq,sK,sR,sJ];class sU extends y{constructor(e={}){super(),this.digestedObjectType=h.H$(e,sq,sU.defaultValues(sq)),sK in e&&(this.otherObjectTypeID=h.H$(e,sK,sU.defaultValues(sK))),this.digestAlgorithm=h.H$(e,sR,sU.defaultValues(sR)),this.objectDigest=h.H$(e,sJ,sU.defaultValues(sJ)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sq:return new o.Enumerated;case sK:return new o.ObjectIdentifier;case sR:return new T;case sJ:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Enumerated({name:t.digestedObjectType||""}),new o.ObjectIdentifier({optional:!0,name:t.otherObjectTypeID||""}),T.schema(t.digestAlgorithm||{}),new o.BitString({name:t.objectDigest||""})]})}fromSchema(e){h.ze(e,sj);let t=o.compareSchema(e,e,sU.schema({names:{digestedObjectType:sq,otherObjectTypeID:sK,digestAlgorithm:{names:{blockName:sR}},objectDigest:sJ}}));S.assertSchema(t,this.className),this.digestedObjectType=t.result.digestedObjectType,sK in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new T({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){let e=new o.Sequence({value:[this.digestedObjectType]});return this.otherObjectTypeID&&e.valueBlock.value.push(this.otherObjectTypeID),e.valueBlock.value.push(this.digestAlgorithm.toSchema()),e.valueBlock.value.push(this.objectDigest),e}toJSON(){let e={digestedObjectType:this.digestedObjectType.toJSON(),digestAlgorithm:this.digestAlgorithm.toJSON(),objectDigest:this.objectDigest.toJSON()};return this.otherObjectTypeID&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e}}sU.CLASS_NAME="ObjectDigestInfo";let sT="issuerName",sL="baseCertificateID",sM="objectDigestInfo",s_=[sT,sL,sM];class sW extends y{constructor(e={}){super(),sT in e&&(this.issuerName=h.H$(e,sT,sW.defaultValues(sT))),sL in e&&(this.baseCertificateID=h.H$(e,sL,sW.defaultValues(sL))),sM in e&&(this.objectDigestInfo=h.H$(e,sM,sW.defaultValues(sM))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sT:return new ea;case sL:return new sy;case sM:return new sU;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[ea.schema({names:{blockName:t.issuerName}},!0),new o.Constructed({optional:!0,name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:sy.schema().valueBlock.value}),new o.Constructed({optional:!0,name:t.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:1},value:sU.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,s_);let t=o.compareSchema(e,e,sW.schema({names:{issuerName:sT,baseCertificateID:sL,objectDigestInfo:sM}}));S.assertSchema(t,this.className),sT in t.result&&(this.issuerName=new ea({schema:t.result.issuerName})),sL in t.result&&(this.baseCertificateID=new sy({schema:new o.Sequence({value:t.result.baseCertificateID.valueBlock.value})})),sM in t.result&&(this.objectDigestInfo=new sU({schema:new o.Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){let e=new o.Sequence;return this.issuerName&&e.valueBlock.value.push(this.issuerName.toSchema()),this.baseCertificateID&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){let e={};return this.issuerName&&(e.issuerName=this.issuerName.toJSON()),this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}sW.CLASS_NAME="V2Form";let sz="baseCertificateID",sF="entityName",sG="objectDigestInfo",sQ=[sz,sF,sG];class sZ extends y{constructor(e={}){super(),sz in e&&(this.baseCertificateID=h.H$(e,sz,sZ.defaultValues(sz))),sF in e&&(this.entityName=h.H$(e,sF,sZ.defaultValues(sF))),sG in e&&(this.objectDigestInfo=h.H$(e,sG,sZ.defaultValues(sG))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sz:return new sy;case sF:return new ea;case sG:return new sU;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({optional:!0,name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:sy.schema().valueBlock.value}),new o.Constructed({optional:!0,name:t.entityName||"",idBlock:{tagClass:3,tagNumber:1},value:ea.schema().valueBlock.value}),new o.Constructed({optional:!0,name:t.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:2},value:sU.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,sQ);let t=o.compareSchema(e,e,sZ.schema({names:{baseCertificateID:sz,entityName:sF,objectDigestInfo:sG}}));S.assertSchema(t,this.className),sz in t.result&&(this.baseCertificateID=new sy({schema:new o.Sequence({value:t.result.baseCertificateID.valueBlock.value})})),sF in t.result&&(this.entityName=new ea({schema:new o.Sequence({value:t.result.entityName.valueBlock.value})})),sG in t.result&&(this.objectDigestInfo=new sU({schema:new o.Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){let e=new o.Sequence;return this.baseCertificateID&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.entityName&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){let e={};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.entityName&&(e.entityName=this.entityName.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}sZ.CLASS_NAME="Holder";let sX="version",sY="holder",s1="issuer",s0="signature",s2="serialNumber",s3="attrCertValidityPeriod",s4="attributes",s8="issuerUniqueID",s5="extensions",s6=[sX,sY,s1,s0,s2,s3,s4,s8,s5];class s9 extends y{constructor(e={}){super(),this.version=h.H$(e,sX,s9.defaultValues(sX)),this.holder=h.H$(e,sY,s9.defaultValues(sY)),this.issuer=h.H$(e,s1,s9.defaultValues(s1)),this.signature=h.H$(e,s0,s9.defaultValues(s0)),this.serialNumber=h.H$(e,s2,s9.defaultValues(s2)),this.attrCertValidityPeriod=h.H$(e,s3,s9.defaultValues(s3)),this.attributes=h.H$(e,s4,s9.defaultValues(s4)),s8 in e&&(this.issuerUniqueID=h.H$(e,s8,s9.defaultValues(s8))),s5 in e&&(this.extensions=h.H$(e,s5,s9.defaultValues(s5))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sX:return 1;case sY:return new sZ;case s1:return{};case s0:return new T;case s2:return new o.Integer;case s3:return new Y;case s4:return[];case s8:return new o.BitString;case s5:return new sd;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),sZ.schema(t.holder||{}),new o.Choice({value:[ea.schema({names:{blockName:t.issuer||""}}),new o.Constructed({name:t.issuer||"",idBlock:{tagClass:3,tagNumber:0},value:sW.schema().valueBlock.value})]}),T.schema(t.signature||{}),new o.Integer({name:t.serialNumber||""}),Y.schema(t.attrCertValidityPeriod||{}),new o.Sequence({name:t.attributes||"",value:[new o.Repeated({value:G.schema()})]}),new o.BitString({optional:!0,name:t.issuerUniqueID||""}),sd.schema(t.extensions||{},!0)]})}fromSchema(e){h.ze(e,s6);let t=o.compareSchema(e,e,s9.schema({names:{version:sX,holder:{names:{blockName:sY}},issuer:s1,signature:{names:{blockName:s0}},serialNumber:s2,attrCertValidityPeriod:{names:{blockName:s3}},attributes:s4,issuerUniqueID:s8,extensions:{names:{blockName:s5}}}}));if(S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.holder=new sZ({schema:t.result.holder}),3===t.result.issuer.idBlock.tagClass)this.issuer=new sW({schema:new o.Sequence({value:t.result.issuer.valueBlock.value})});else throw Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");this.signature=new T({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new Y({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new G({schema:e})),s8 in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),s5 in t.result&&(this.extensions=new sd({schema:t.result.extensions}))}toSchema(){let e=new o.Sequence({value:[new o.Integer({value:this.version}),this.holder.toSchema(),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new o.Sequence({value:Array.from(this.attributes,e=>e.toSchema())})]});return this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){let e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,e=>e.toJSON())};return this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}s9.CLASS_NAME="AttributeCertificateInfoV2";let s7="acinfo",re="signatureAlgorithm",rt="signatureValue",ra=[s7,re,rt];class rs extends y{constructor(e={}){super(),this.acinfo=h.H$(e,s7,rs.defaultValues(s7)),this.signatureAlgorithm=h.H$(e,re,rs.defaultValues(re)),this.signatureValue=h.H$(e,rt,rs.defaultValues(rt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case s7:return new s9;case re:return new T;case rt:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[s9.schema(t.acinfo||{}),T.schema(t.signatureAlgorithm||{}),new o.BitString({name:t.signatureValue||""})]})}fromSchema(e){h.ze(e,ra);let t=o.compareSchema(e,e,rs.schema({names:{acinfo:{names:{blockName:s7}},signatureAlgorithm:{names:{blockName:re}},signatureValue:rt}}));S.assertSchema(t,this.className),this.acinfo=new s9({schema:t.result.acinfo}),this.signatureAlgorithm=new T({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new o.Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}rs.CLASS_NAME="AttributeCertificateV2";let rr="contentType",ri="content",rn=[rr,ri];class rl extends y{constructor(e={}){super(),this.contentType=h.H$(e,rr,rl.defaultValues(rr)),this.content=h.H$(e,ri,rl.defaultValues(ri)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rr:return"";case ri:return new o.Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case rr:return"string"==typeof t&&t===this.defaultValues(rr);case ri:return t instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new o.Sequence({name:t.blockName||"ContentInfo",optional:t.optional,value:[new o.ObjectIdentifier({name:t.contentType||rr}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.content||ri})]})]})}fromSchema(e){h.ze(e,rn);let t=o.compareSchema(e,e,rl.schema());S.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.contentType}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){let e={contentType:this.contentType};return this.content instanceof o.Any||(e.content=this.content.toJSON()),e}}rl.CLASS_NAME="ContentInfo",rl.DATA=eS,rl.SIGNED_DATA=ey,rl.ENVELOPED_DATA=ew,rl.ENCRYPTED_DATA=ev;let ru="type",ro="value",rc="utcTimeName",rh="generalTimeName",rm=[rc,rh];(s=n||(n={}))[s.UTCTime=0]="UTCTime",s[s.GeneralizedTime=1]="GeneralizedTime",s[s.empty=2]="empty";class rd extends y{constructor(e={}){super(),this.type=h.H$(e,ru,rd.defaultValues(ru)),this.value=h.H$(e,ro,rd.defaultValues(ro)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ru:return 0;case ro:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={},t=!1){let a=h.H$(e,"names",{});return new o.Choice({optional:t,value:[new o.UTCTime({name:a.utcTimeName||""}),new o.GeneralizedTime({name:a.generalTimeName||""})]})}fromSchema(e){h.ze(e,rm);let t=o.compareSchema(e,e,rd.schema({names:{utcTimeName:rc,generalTimeName:rh}}));S.assertSchema(t,this.className),rc in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),rh in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){return 0===this.type?new o.UTCTime({valueDate:this.value}):1===this.type?new o.GeneralizedTime({valueDate:this.value}):{}}toJSON(){return{type:this.type,value:this.value}}}rd.CLASS_NAME="Time";let rf="version",rg="serialNumber",rp="signature",rS="issuer",ry="notBefore",rw="notAfter",rv="subject",rb="subjectPublicKeyInfo",rA="issuerUniqueID",rk="subjectUniqueID",rC="extensions",rN="signatureAlgorithm",rV="signatureValue",rI="tbsCertificate",rB=`${rI}.${rf}`,rE=`${rI}.${rg}`,rH=`${rI}.${rp}`,rD=`${rI}.${rS}`,rO=`${rI}.${ry}`,rx=`${rI}.${rw}`,r$=`${rI}.${rv}`,rP=`${rI}.${rb}`,rq=`${rI}.${rA}`,rK=`${rI}.${rk}`,rR=`${rI}.${rC}`,rJ=[rI,rB,rE,rH,rD,rO,rx,r$,rP,rq,rK,rR,rN,rV];class rj extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",rj.defaultValues("tbs"))),this.version=h.H$(e,rf,rj.defaultValues(rf)),this.serialNumber=h.H$(e,rg,rj.defaultValues(rg)),this.signature=h.H$(e,rp,rj.defaultValues(rp)),this.issuer=h.H$(e,rS,rj.defaultValues(rS)),this.notBefore=h.H$(e,ry,rj.defaultValues(ry)),this.notAfter=h.H$(e,rw,rj.defaultValues(rw)),this.subject=h.H$(e,rv,rj.defaultValues(rv)),this.subjectPublicKeyInfo=h.H$(e,rb,rj.defaultValues(rb)),rA in e&&(this.issuerUniqueID=h.H$(e,rA,rj.defaultValues(rA))),rk in e&&(this.subjectUniqueID=h.H$(e,rk,rj.defaultValues(rk))),rC in e&&(this.extensions=h.H$(e,rC,rj.defaultValues(rC))),this.signatureAlgorithm=h.H$(e,rN,rj.defaultValues(rN)),this.signatureValue=h.H$(e,rV,rj.defaultValues(rV)),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return f;case rf:return 0;case rg:return new o.Integer;case rp:return new T;case rS:return new N;case ry:case rw:return new rd;case rv:return new N;case rb:return new tZ;case rA:case rk:return f;case rC:return[];case rN:return new T;case rV:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[function(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||rI,value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.tbsCertificateVersion||rB})]}),new o.Integer({name:t.tbsCertificateSerialNumber||rE}),T.schema(t.signature||{names:{blockName:rH}}),N.schema(t.issuer||{names:{blockName:rD}}),new o.Sequence({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[rd.schema(t.notBefore||{names:{utcTimeName:rO,generalTimeName:rO}}),rd.schema(t.notAfter||{names:{utcTimeName:rx,generalTimeName:rx}})]}),N.schema(t.subject||{names:{blockName:r$}}),tZ.schema(t.subjectPublicKeyInfo||{names:{blockName:rP}}),new o.Primitive({name:t.tbsCertificateIssuerUniqueID||rq,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new o.Primitive({name:t.tbsCertificateSubjectUniqueID||rK,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[sd.schema(t.extensions||{names:{blockName:rR}})]})]})}(t.tbsCertificate),T.schema(t.signatureAlgorithm||{names:{blockName:rN}}),new o.BitString({name:t.signatureValue||rV})]})}fromSchema(e){h.ze(e,rJ);let t=o.compareSchema(e,e,rj.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:rR}}}}}}));S.assertSchema(t,this.className),this.tbsView=t.result.tbsCertificate.valueBeforeDecodeView,rB in t.result&&(this.version=t.result[rB].valueBlock.valueDec),this.serialNumber=t.result[rE],this.signature=new T({schema:t.result[rH]}),this.issuer=new N({schema:t.result[rD]}),this.notBefore=new rd({schema:t.result[rO]}),this.notAfter=new rd({schema:t.result[rx]}),this.subject=new N({schema:t.result[r$]}),this.subjectPublicKeyInfo=new tZ({schema:t.result[rP]}),rq in t.result&&(this.issuerUniqueID=t.result[rq].valueBlock.valueHex),rK in t.result&&(this.subjectUniqueID=t.result[rK].valueBlock.valueHex),rR in t.result&&(this.extensions=Array.from(t.result[rR],e=>new sc({schema:e}))),this.signatureAlgorithm=new T({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[];return rf in this&&this.version!==rj.defaultValues(rf)&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new o.Sequence({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),this.issuerUniqueID&&e.push(new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),this.subjectUniqueID&&e.push(new o.Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),this.extensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new o.Sequence({value:Array.from(this.extensions,e=>e.toSchema())})]})),new o.Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return rj.schema().value[0];let e=o.fromBER(this.tbsView);S.assert(e,"TBS Certificate"),t=e.result}else t=this.encodeTBS();return new o.Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:c.ep.ToHex(this.tbsView),version:this.version,serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return rf in this&&this.version!==rj.defaultValues(rf)&&(e.version=this.version),this.issuerUniqueID&&(e.issuerUniqueID=c.ep.ToHex(this.issuerUniqueID)),this.subjectUniqueID&&(e.subjectUniqueID=c.ep.ToHex(this.subjectUniqueID)),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async getPublicKey(e,t=aM(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}async getKeyHash(e="SHA-1",t=aM(!0)){return t.digest({name:e},this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView)}async sign(e,t="SHA-1",a=aM(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),r=s.parameters;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let i=await a.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new o.BitString({valueHex:i})}async verify(e,t=aM(!0)){let a;if(e?a=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(a=this.subjectPublicKeyInfo),!(a instanceof tZ))throw Error("Please provide issuer certificate as a parameter");return t.verifyWithPublicKey(this.tbsView,this.signatureValue,a,this.signatureAlgorithm)}}function rU(e,t=null){if(t&&e.issuer.isEqual(t.issuer)&&e.serialNumber.isEqual(t.serialNumber))return null;let a=!1;if(e.extensions){for(let t of e.extensions)if(t.extnID===ei&&t.parsedValue instanceof eD&&t.parsedValue.cA){a=!0;break}}return a?e:null}rj.CLASS_NAME="Certificate";let rT="certId",rL="certValue",rM="parsedValue",r_=[rT,rL];class rW extends y{constructor(e={}){super(),this.certId=h.H$(e,rT,rW.defaultValues(rT)),this.certValue=h.H$(e,rL,rW.defaultValues(rL)),rM in e&&(this.parsedValue=h.H$(e,rM,rW.defaultValues(rM))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rT:return"";case rL:return new o.Any;case rM:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case rT:return""===t;case rL:return t instanceof o.Any;case rM:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||"id"}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.value||"value"})]})]})}fromSchema(e){h.ze(e,r_);let t=o.compareSchema(e,e,rW.schema({names:{id:rT,value:rL}}));S.assertSchema(t,this.className),this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue;let a=this.certValue.valueBlock.valueHexView;switch(this.certId){case eb:try{this.parsedValue=rj.fromBER(a)}catch(e){rs.fromBER(a)}break;case eA:this.parsedValue=rs.fromBER(a);break;default:throw Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`)}}toSchema(){return rM in this&&("acinfo"in this.parsedValue?this.certId=eA:this.certId=eb,this.certValue=new o.OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new o.Sequence({value:[new o.ObjectIdentifier({value:this.certId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}rW.CLASS_NAME="CertBag";let rz="userCertificate",rF="revocationDate",rG="crlEntryExtensions",rQ=[rz,rF,rG];class rZ extends y{constructor(e={}){super(),this.userCertificate=h.H$(e,rz,rZ.defaultValues(rz)),this.revocationDate=h.H$(e,rF,rZ.defaultValues(rF)),rG in e&&(this.crlEntryExtensions=h.H$(e,rG,rZ.defaultValues(rG))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case rz:return new o.Integer;case rF:return new rd;case rG:return new sd;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.userCertificate||rz}),rd.schema({names:{utcTimeName:t.revocationDate||rF,generalTimeName:t.revocationDate||rF}}),sd.schema({names:{blockName:t.crlEntryExtensions||rG}},!0)]})}fromSchema(e){h.ze(e,rQ);let t=o.compareSchema(e,e,rZ.schema());S.assertSchema(t,this.className),this.userCertificate=t.result.userCertificate,this.revocationDate=new rd({schema:t.result.revocationDate}),rG in t.result&&(this.crlEntryExtensions=new sd({schema:t.result.crlEntryExtensions}))}toSchema(){let e=[this.userCertificate,this.revocationDate.toSchema()];return this.crlEntryExtensions&&e.push(this.crlEntryExtensions.toSchema()),new o.Sequence({value:e})}toJSON(){let e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON()};return this.crlEntryExtensions&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}rZ.CLASS_NAME="RevokedCertificate";let rX="version",rY="signature",r1="issuer",r0="thisUpdate",r2="nextUpdate",r3="revokedCertificates",r4="crlExtensions",r8="signatureAlgorithm",r5="signatureValue",r6="tbsCertList",r9=`${r6}.version`,r7=`${r6}.signature`,ie=`${r6}.issuer`,it=`${r6}.thisUpdate`,ia=`${r6}.nextUpdate`,is=`${r6}.revokedCertificates`,ir=`${r6}.extensions`,ii=[r6,r9,r7,ie,it,ia,is,ir,r8,r5],il=[ef,er,"2.5.29.20","2.5.29.27",en,ec,ep,"2.5.29.21","2.5.29.24",el];class iu extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",iu.defaultValues("tbs"))),this.version=h.H$(e,rX,iu.defaultValues(rX)),this.signature=h.H$(e,rY,iu.defaultValues(rY)),this.issuer=h.H$(e,r1,iu.defaultValues(r1)),this.thisUpdate=h.H$(e,r0,iu.defaultValues(r0)),r2 in e&&(this.nextUpdate=h.H$(e,r2,iu.defaultValues(r2))),r3 in e&&(this.revokedCertificates=h.H$(e,r3,iu.defaultValues(r3))),r4 in e&&(this.crlExtensions=h.H$(e,r4,iu.defaultValues(r4))),this.signatureAlgorithm=h.H$(e,r8,iu.defaultValues(r8)),this.signatureValue=h.H$(e,r5,iu.defaultValues(r5)),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return f;case rX:return 0;case rY:return new T;case r1:return new N;case r0:case r2:return new rd;case r3:return[];case r4:return new sd;case r8:return new T;case r5:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"CertificateList",value:[function(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||r6,value:[new o.Integer({optional:!0,name:t.tbsCertListVersion||r9,value:2}),T.schema(t.signature||{names:{blockName:r7}}),N.schema(t.issuer||{names:{blockName:ie}}),rd.schema(t.tbsCertListThisUpdate||{names:{utcTimeName:it,generalTimeName:it}}),rd.schema(t.tbsCertListNextUpdate||{names:{utcTimeName:ia,generalTimeName:ia}},!0),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.tbsCertListRevokedCertificates||is,value:new o.Sequence({value:[new o.Integer,rd.schema(),sd.schema({},!0)]})})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[sd.schema(t.crlExtensions||{names:{blockName:ir}})]})]})}(e),T.schema(t.signatureAlgorithm||{names:{blockName:r8}}),new o.BitString({name:t.signatureValue||r5})]})}fromSchema(e){h.ze(e,ii);let t=o.compareSchema(e,e,iu.schema());S.assertSchema(t,this.className),this.tbsView=t.result.tbsCertList.valueBeforeDecodeView,r9 in t.result&&(this.version=t.result[r9].valueBlock.valueDec),this.signature=new T({schema:t.result[r7]}),this.issuer=new N({schema:t.result[ie]}),this.thisUpdate=new rd({schema:t.result[it]}),ia in t.result&&(this.nextUpdate=new rd({schema:t.result[ia]})),is in t.result&&(this.revokedCertificates=Array.from(t.result[is],e=>new rZ({schema:e}))),ir in t.result&&(this.crlExtensions=new sd({schema:t.result[ir]})),this.signatureAlgorithm=new T({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[];return this.version!==iu.defaultValues(rX)&&e.push(new o.Integer({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),this.nextUpdate&&e.push(this.nextUpdate.toSchema()),this.revokedCertificates&&e.push(new o.Sequence({value:Array.from(this.revokedCertificates,e=>e.toSchema())})),this.crlExtensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new o.Sequence({value:e})}toSchema(e=!1){let t;if(e)t=this.encodeTBS();else{if(!this.tbsView.byteLength)return iu.schema();let e=o.fromBER(this.tbsView);S.assert(e,"TBS Certificate Revocation List"),t=e.result}return new o.Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:c.ep.ToHex(this.tbsView),version:this.version,signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==iu.defaultValues(rX)&&(e.version=this.version),this.nextUpdate&&(e.nextUpdate=this.nextUpdate.toJSON()),this.revokedCertificates&&(e.revokedCertificates=Array.from(this.revokedCertificates,e=>e.toJSON())),this.crlExtensions&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!this.issuer.isEqual(e.issuer)||!this.revokedCertificates)return!1;for(let t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}async sign(e,t="SHA-1",a=aM(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),{parameters:r}=s;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let i=await a.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new o.BitString({valueHex:i})}async verify(e={},t=aM(!0)){let a;if(e.issuerCertificate&&(a=e.issuerCertificate.subjectPublicKeyInfo,!this.issuer.isEqual(e.issuerCertificate.subject)))return!1;if(e.publicKeyInfo&&(a=e.publicKeyInfo),!a)throw Error("Issuer's certificate must be provided as an input parameter");if(this.crlExtensions){for(let e of this.crlExtensions.extensions)if(e.critical&&!il.includes(e.extnID))return!1}return t.verifyWithPublicKey(this.tbsView,this.signatureValue,a,this.signatureAlgorithm)}}iu.CLASS_NAME="CertificateRevocationList";let io="crlId",ic="crlValue",ih="parsedValue",im=[io,ic];class id extends y{constructor(e={}){super(),this.crlId=h.H$(e,io,id.defaultValues(io)),this.crlValue=h.H$(e,ic,id.defaultValues(ic)),ih in e&&(this.parsedValue=h.H$(e,ih,id.defaultValues(ih))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case io:return"";case ic:return new o.Any;case ih:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case io:return""===t;case ic:return t instanceof o.Any;case ih:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||"id"}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.value||"value"})]})]})}fromSchema(e){h.ze(e,im);let t=o.compareSchema(e,e,id.schema({names:{id:io,value:ic}}));if(S.assertSchema(t,this.className),this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId===ek)this.parsedValue=iu.fromBER(this.certValue.valueBlock.valueHex);else throw Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`)}toSchema(){return this.parsedValue&&(this.crlId=ek,this.crlValue=new o.OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new o.Sequence({value:[new o.ObjectIdentifier({value:this.crlId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}id.CLASS_NAME="CRLBag";let ig="version",ip="encryptedContentInfo",iS="unprotectedAttrs",iy=[ig,ip,iS];class iw extends y{constructor(e={}){super(),this.version=h.H$(e,ig,iw.defaultValues(ig)),this.encryptedContentInfo=h.H$(e,ip,iw.defaultValues(ip)),iS in e&&(this.unprotectedAttrs=h.H$(e,iS,iw.defaultValues(iS))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ig:return 0;case ip:return new aA;case iS:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ig:return 0===t;case ip:return aA.compareWithDefault("contentType",t.contentType)&&aA.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&aA.compareWithDefault("encryptedContent",t.encryptedContent);case iS:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),aA.schema(t.encryptedContentInfo||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.unprotectedAttrs||"",value:G.schema()})]})]})}fromSchema(e){h.ze(e,iy);let t=o.compareSchema(e,e,iw.schema({names:{version:ig,encryptedContentInfo:{names:{blockName:ip}},unprotectedAttrs:iS}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new aA({schema:t.result.encryptedContentInfo}),iS in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new G({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}async encrypt(e,t=aM(!0)){g.assert(e,"parameters","object");let a={...e,contentType:"1.2.840.113549.1.7.1"};this.encryptedContentInfo=await t.encryptEncryptedContentInfo(a)}async decrypt(e,t=aM(!0)){g.assert(e,"parameters","object");let a={...e,encryptedContentInfo:this.encryptedContentInfo};return t.decryptEncryptedContentInfo(a)}}iw.CLASS_NAME="EncryptedData";let iv="encryptionAlgorithm",ib="encryptedData",iA="parsedValue",ik=[iv,ib];class iC extends y{constructor(e={}){super(),this.encryptionAlgorithm=h.H$(e,iv,iC.defaultValues(iv)),this.encryptedData=h.H$(e,ib,iC.defaultValues(ib)),iA in e&&(this.parsedValue=h.H$(e,iA,iC.defaultValues(iA))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iv:return new T;case ib:return new o.OctetString;case iA:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iv:return T.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case ib:return t.isEqual(iC.defaultValues(e));case iA:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.encryptionAlgorithm||{names:{blockName:iv}}),new o.Choice({value:[new o.OctetString({name:t.encryptedData||ib}),new o.OctetString({idBlock:{isConstructed:!0},name:t.encryptedData||ib})]})]})}fromSchema(e){h.ze(e,ik);let t=o.compareSchema(e,e,iC.schema({names:{encryptionAlgorithm:{names:{blockName:iv}},encryptedData:ib}}));S.assertSchema(t,this.className),this.encryptionAlgorithm=new T({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new o.Sequence({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}async parseInternalValues(e,t=aM(!0)){let a=new iw({encryptedContentInfo:new aA({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})}),s=await a.decrypt(e,t);this.parsedValue=aS.fromBER(s)}async makeInternalValues(e,t=aM(!0)){if(!this.parsedValue)throw Error('Please initialize "parsedValue" first');let a=new iw,s={...e,contentToEncrypt:this.parsedValue.toSchema().toBER(!1)};if(await a.encrypt(s,t),!a.encryptedContentInfo.encryptedContent)throw Error("The filed `encryptedContent` in EncryptedContentInfo is empty");this.encryptionAlgorithm=a.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=a.encryptedContentInfo.encryptedContent}}iC.CLASS_NAME="PKCS8ShroudedKeyBag";let iN="secretTypeId",iV="secretValue",iI=[iN,iV];class iB extends y{constructor(e={}){super(),this.secretTypeId=h.H$(e,iN,iB.defaultValues(iN)),this.secretValue=h.H$(e,iV,iB.defaultValues(iV)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iN:return"";case iV:return new o.Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iN:return""===t;case iV:return t instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.id||"id"}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.value||"value"})]})]})}fromSchema(e){h.ze(e,iI);let t=o.compareSchema(e,e,iB.schema({names:{id:iN,value:iV}}));S.assertSchema(t,this.className),this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.secretTypeId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}iB.CLASS_NAME="SecretBag";class iE{static getItems(){return this.items||(this.items={},iE.register("1.2.840.113549.1.12.10.1.1",aS),iE.register("1.2.840.113549.1.12.10.1.2",iC),iE.register("1.2.840.113549.1.12.10.1.3",rW),iE.register("1.2.840.113549.1.12.10.1.4",id),iE.register("1.2.840.113549.1.12.10.1.5",iB),iE.register("1.2.840.113549.1.12.10.1.6",iq)),this.items}static register(e,t){this.getItems()[e]=t}static find(e){return this.getItems()[e]||null}}let iH="bagId",iD="bagValue",iO="bagAttributes",ix=[iH,iD,iO];class i$ extends y{constructor(e={}){super(),this.bagId=h.H$(e,iH,i$.defaultValues(iH)),this.bagValue=h.H$(e,iD,i$.defaultValues(iD)),iO in e&&(this.bagAttributes=h.H$(e,iO,i$.defaultValues(iO))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iH:return"";case iD:return new o.Any;case iO:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iH:return""===t;case iD:return t instanceof o.Any;case iO:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.bagId||iH}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.bagValue||iD})]}),new o.Set({optional:!0,value:[new o.Repeated({name:t.bagAttributes||iO,value:G.schema()})]})]})}fromSchema(e){h.ze(e,ix);let t=o.compareSchema(e,e,i$.schema({names:{bagId:iH,bagValue:iD,bagAttributes:iO}}));S.assertSchema(t,this.className),this.bagId=t.result.bagId.valueBlock.toString();let a=iE.find(this.bagId);if(!a)throw Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);this.bagValue=new a({schema:t.result.bagValue}),iO in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,e=>new G({schema:e})))}toSchema(){let e=[new o.ObjectIdentifier({value:this.bagId}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return this.bagAttributes&&e.push(new o.Set({value:Array.from(this.bagAttributes,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return this.bagAttributes&&(e.bagAttributes=Array.from(this.bagAttributes,e=>e.toJSON())),e}}i$.CLASS_NAME="SafeBag";let iP="safeBags";class iq extends y{constructor(e={}){super(),this.safeBags=h.H$(e,iP,iq.defaultValues(iP)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===iP?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===iP?0===t.length:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.safeBags||"",value:i$.schema()})]})}fromSchema(e){h.ze(e,[iP]);let t=o.compareSchema(e,e,iq.schema({names:{safeBags:iP}}));S.assertSchema(t,this.className),this.safeBags=Array.from(t.result.safeBags,e=>new i$({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}}iq.CLASS_NAME="SafeContents";let iK="otherCertFormat",iR="otherCert",iJ=[iK,iR];class ij extends y{constructor(e={}){super(),this.otherCertFormat=h.H$(e,iK,ij.defaultValues(iK)),this.otherCert=h.H$(e,iR,ij.defaultValues(iR)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iK:return"";case iR:return new o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.otherCertFormat||iK}),new o.Any({name:t.otherCert||iR})]})}fromSchema(e){h.ze(e,iJ);let t=o.compareSchema(e,e,ij.schema());S.assertSchema(t,this.className),this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.otherCertFormat}),this.otherCert]})}toJSON(){let e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof o.Any||(e.otherCert=this.otherCert.toJSON()),e}}let iU="certificates",iT=[iU];class iL extends y{constructor(e={}){super(),this.certificates=h.H$(e,iU,iL.defaultValues(iU)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===iU?[]:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Set({name:t.blockName||"",value:[new o.Repeated({name:t.certificates||iU,value:new o.Choice({value:[rj.schema(),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Any]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.Sequence]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:rs.schema().valueBlock.value}),new o.Constructed({idBlock:{tagClass:3,tagNumber:3},value:ij.schema().valueBlock.value})]})})]})}fromSchema(e){h.ze(e,iT);let t=o.compareSchema(e,e,iL.schema());S.assertSchema(t,this.className),this.certificates=Array.from(t.result.certificates||[],e=>{let t=e.idBlock.tagNumber;if(1===e.idBlock.tagClass)return new rj({schema:e});let a=new o.Sequence({value:e.valueBlock.value});switch(t){case 1:if(1===a.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec)return new rs({schema:a});return new sP({schema:a});case 2:return new rs({schema:a});case 3:return new ij({schema:a})}return e})}toSchema(){return new o.Set({value:Array.from(this.certificates,e=>{switch(!0){case e instanceof rj:break;case e instanceof sP:return new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:e.toSchema().valueBlock.value});case e instanceof rs:return new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:e.toSchema().valueBlock.value});case e instanceof ij:return new o.Constructed({idBlock:{tagClass:3,tagNumber:3},value:e.toSchema().valueBlock.value})}return e.toSchema()})})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}}iL.CLASS_NAME="CertificateSet";let iM="otherRevInfoFormat",i_="otherRevInfo",iW=[iM,i_];class iz extends y{constructor(e={}){super(),this.otherRevInfoFormat=h.H$(e,iM,iz.defaultValues(iM)),this.otherRevInfo=h.H$(e,i_,iz.defaultValues(i_)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iM:return"";case i_:return new o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.otherRevInfoFormat||iM}),new o.Any({name:t.otherRevInfo||i_})]})}fromSchema(e){h.ze(e,iW);let t=o.compareSchema(e,e,iz.schema());S.assertSchema(t,this.className),this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){let e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof o.Any||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}iz.CLASS_NAME="OtherRevocationInfoFormat";let iF="crls",iG="otherRevocationInfos",iQ=[iF];class iZ extends y{constructor(e={}){super(),this.crls=h.H$(e,iF,iZ.defaultValues(iF)),this.otherRevocationInfos=h.H$(e,iG,iZ.defaultValues(iG)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iF:case iG:return[];default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Set({name:t.blockName||"",value:[new o.Repeated({name:t.crls||"",value:new o.Choice({value:[iu.schema(),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.ObjectIdentifier,new o.Any]})]})})]})}fromSchema(e){h.ze(e,iQ);let t=o.compareSchema(e,e,iZ.schema({names:{crls:iF}}));if(S.assertSchema(t,this.className),t.result.crls)for(let e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new iu({schema:e})):this.otherRevocationInfos.push(new iz({schema:e}))}toSchema(){let e=[];return e.push(...Array.from(this.crls,e=>e.toSchema())),e.push(...Array.from(this.otherRevocationInfos,e=>{let t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t})),new o.Set({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}}iZ.CLASS_NAME="RevocationInfoChoices";let iX="certs",iY="crls",i1=[iX,iY];class i0 extends y{constructor(e={}){super(),this.crls=h.H$(e,iY,i0.defaultValues(iY)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case iX:return new iL;case iY:return new iZ;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case iX:return 0===t.certificates.length;case iY:return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({name:t.certs||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:iL.schema().valueBlock.value}),new o.Constructed({name:t.crls||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:iZ.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,i1);let t=o.compareSchema(e,e,i0.schema({names:{certs:iX,crls:iY}}));S.assertSchema(t,this.className),iX in t.result&&(this.certs=new iL({schema:new o.Set({value:t.result.certs.valueBlock.value})})),iY in t.result&&(this.crls=new iZ({schema:new o.Set({value:t.result.crls.valueBlock.value})}))}toSchema(){let e=[];return this.certs&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value})),this.crls&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})),new o.Sequence({value:e})}toJSON(){let e={};return this.certs&&(e.certs=this.certs.toJSON()),this.crls&&(e.crls=this.crls.toJSON()),e}}i0.CLASS_NAME="OriginatorInfo";let i2="issuer",i3="serialNumber",i4=[i2,i3];class i8 extends y{constructor(e={}){super(),this.issuer=h.H$(e,i2,i8.defaultValues(i2)),this.serialNumber=h.H$(e,i3,i8.defaultValues(i3)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case i2:return new N;case i3:return new o.Integer;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[N.schema(t.issuer||{}),new o.Integer({name:t.serialNumber||""})]})}fromSchema(e){h.ze(e,i4);let t=o.compareSchema(e,e,i8.schema({names:{issuer:{names:{blockName:i2}},serialNumber:i3}}));S.assertSchema(t,this.className),this.issuer=new N({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new o.Sequence({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}i8.CLASS_NAME="IssuerAndSerialNumber";let i5="variant",i6="value",i9=["blockName"];class i7 extends y{constructor(e={}){super(),this.variant=h.H$(e,i5,i7.defaultValues(i5)),i6 in e&&(this.value=h.H$(e,i6,i7.defaultValues(i6))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case i5:return -1;case i6:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case i5:return -1===t;case i6:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[i8.schema({names:{blockName:t.blockName||""}}),new o.Primitive({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:0}})]})}fromSchema(e){h.ze(e,i9);let t=o.compareSchema(e,e,i7.schema({names:{blockName:"blockName"}}));S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new i8({schema:t.result.blockName})):(this.variant=2,this.value=new o.OctetString({valueHex:t.result.blockName.valueBlock.valueHex}))}toSchema(){switch(this.variant){case 1:if(!(this.value instanceof i8))throw Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");return this.value.toSchema();case 2:if(!(this.value instanceof o.OctetString))throw Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");return new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.value.valueBlock.valueHexView});default:return new o.Any}}toJSON(){let e={variant:this.variant};return(1===this.variant||2===this.variant)&&this.value&&(e.value=this.value.toJSON()),e}}i7.CLASS_NAME="RecipientIdentifier";let ne="version",nt="keyEncryptionAlgorithm",na="encryptedKey",ns="recipientCertificate",nr=[ne,"rid",nt,na];class ni extends y{constructor(e={}){super(),this.version=h.H$(e,ne,ni.defaultValues(ne)),this.rid=h.H$(e,"rid",ni.defaultValues("rid")),this.keyEncryptionAlgorithm=h.H$(e,nt,ni.defaultValues(nt)),this.encryptedKey=h.H$(e,na,ni.defaultValues(na)),this.recipientCertificate=h.H$(e,ns,ni.defaultValues(ns)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ne:return -1;case"rid":return{};case nt:return new T;case na:return new o.OctetString;case ns:return new rj;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ne:return t===ni.defaultValues(ne);case"rid":return 0===Object.keys(t).length;case nt:case na:return t.isEqual(ni.defaultValues(e));case ns:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),i7.schema(t.rid||{}),T.schema(t.keyEncryptionAlgorithm||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,nr);let t=o.compareSchema(e,e,ni.schema({names:{version:ne,rid:{names:{blockName:"rid"}},keyEncryptionAlgorithm:{names:{blockName:nt}},encryptedKey:na}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=new o.OctetString({valueHex:t.result.rid.valueBlock.valueHex}):this.rid=new i8({schema:t.result.rid}),this.keyEncryptionAlgorithm=new T({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){let e=[];return this.rid instanceof i8?(this.version=0,e.push(new o.Integer({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new o.Integer({value:this.version})),e.push(new o.Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.rid.valueBlock.valueHexView}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new o.Sequence({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}ni.CLASS_NAME="KeyTransRecipientInfo";let nn="algorithm",nl="publicKey",nu=[nn,nl];class no extends y{constructor(e={}){super(),this.algorithm=h.H$(e,nn,no.defaultValues(nn)),this.publicKey=h.H$(e,nl,no.defaultValues(nl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nn:return new T;case nl:return new o.BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nn:case nl:return t.isEqual(no.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.algorithm||{}),new o.BitString({name:t.publicKey||""})]})}fromSchema(e){h.ze(e,nu);let t=o.compareSchema(e,e,no.schema({names:{algorithm:{names:{blockName:nn}},publicKey:nl}}));S.assertSchema(t,this.className),this.algorithm=new T({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new o.Sequence({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}no.CLASS_NAME="OriginatorPublicKey";let nc="variant",nh="value",nm=["blockName"];class nd extends y{constructor(e={}){super(),this.variant=h.H$(e,nc,nd.defaultValues(nc)),nh in e&&(this.value=h.H$(e,nh,nd.defaultValues(nh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nc:return -1;case nh:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nc:return -1===t;case nh:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[i8.schema({names:{blockName:t.blockName||""}}),new o.Primitive({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||""}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||"",value:no.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,nm);let t=o.compareSchema(e,e,nd.schema({names:{blockName:"blockName"}}));S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new i8({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(this.variant=3,this.value=new no({schema:new o.Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{let e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new o.Any}}toJSON(){let e={variant:this.variant};return(1===this.variant||2===this.variant||3===this.variant)&&(e.value=this.value.toJSON()),e}}nd.CLASS_NAME="OriginatorIdentifierOrKey";let nf="keyAttrId",ng="keyAttr",np=[nf,ng];class nS extends y{constructor(e={}){super(),this.keyAttrId=h.H$(e,nf,nS.defaultValues(nf)),ng in e&&(this.keyAttr=h.H$(e,ng,nS.defaultValues(ng))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nf:return"";case ng:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nf:return"string"==typeof t&&""===t;case ng:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({optional:t.optional||!0,name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.keyAttrId||""}),new o.Any({optional:!0,name:t.keyAttr||""})]})}fromSchema(e){h.ze(e,np);let t=o.compareSchema(e,e,nS.schema({names:{keyAttrId:nf,keyAttr:ng}}));S.assertSchema(t,this.className),this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),ng in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.keyAttrId})),ng in this&&e.push(this.keyAttr),new o.Sequence({value:e})}toJSON(){let e={keyAttrId:this.keyAttrId};return ng in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}nS.CLASS_NAME="OtherKeyAttribute";let ny="subjectKeyIdentifier",nw="date",nv="other",nb=[ny,nw,nv];class nA extends y{constructor(e={}){super(),this.subjectKeyIdentifier=h.H$(e,ny,nA.defaultValues(ny)),nw in e&&(this.date=h.H$(e,nw,nA.defaultValues(nw))),nv in e&&(this.other=h.H$(e,nv,nA.defaultValues(nv))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ny:return new o.OctetString;case nw:return new o.GeneralizedTime;case nv:return new nS;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ny:return t.isEqual(nA.defaultValues(ny));case nw:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case nv:return""===t.keyAttrId&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.OctetString({name:t.subjectKeyIdentifier||""}),new o.GeneralizedTime({optional:!0,name:t.date||""}),nS.schema(t.other||{})]})}fromSchema(e){h.ze(e,nb);let t=o.compareSchema(e,e,nA.schema({names:{subjectKeyIdentifier:ny,date:nw,other:{names:{blockName:nv}}}}));S.assertSchema(t,this.className),this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,nw in t.result&&(this.date=t.result.date),nv in t.result&&(this.other=new nS({schema:t.result.other}))}toSchema(){let e=[];return e.push(this.subjectKeyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new o.Sequence({value:e})}toJSON(){let e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return this.date&&(e.date=this.date.toJSON()),this.other&&(e.other=this.other.toJSON()),e}}nA.CLASS_NAME="RecipientKeyIdentifier";let nk="variant",nC="value",nN=["blockName"];class nV extends y{constructor(e={}){super(),this.variant=h.H$(e,nk,nV.defaultValues(nk)),this.value=h.H$(e,nC,nV.defaultValues(nC)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nk:return -1;case nC:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nk:return -1===t;case nC:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[i8.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||""}}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:0},value:nA.schema(t.rKeyId||{names:{blockName:t.blockName||""}}).valueBlock.value})]})}fromSchema(e){h.ze(e,nN);let t=o.compareSchema(e,e,nV.schema({names:{blockName:"blockName"}}));S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new i8({schema:t.result.blockName})):(this.variant=2,this.value=new nA({schema:new o.Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new o.Any}}toJSON(){let e={variant:this.variant};return(1===this.variant||2===this.variant)&&(e.value=this.value.toJSON()),e}}nV.CLASS_NAME="KeyAgreeRecipientIdentifier";let nI="encryptedKey",nB=["rid",nI];class nE extends y{constructor(e={}){super(),this.rid=h.H$(e,"rid",nE.defaultValues("rid")),this.encryptedKey=h.H$(e,nI,nE.defaultValues(nI)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"rid":return new nV;case nI:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"rid":return -1===t.variant&&"value"in t==!1;case nI:return t.isEqual(nE.defaultValues(nI));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[nV.schema(t.rid||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,nB);let t=o.compareSchema(e,e,nE.schema({names:{rid:{names:{blockName:"rid"}},encryptedKey:nI}}));S.assertSchema(t,this.className),this.rid=new nV({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new o.Sequence({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}nE.CLASS_NAME="RecipientEncryptedKey";let nH="encryptedKeys",nD="RecipientEncryptedKeys",nO=[nD];class nx extends y{constructor(e={}){super(),this.encryptedKeys=h.H$(e,nH,nx.defaultValues(nH)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===nH?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===nH?0===t.length:super.defaultValues(e)}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.RecipientEncryptedKeys||"",value:nE.schema()})]})}fromSchema(e){h.ze(e,nO);let t=o.compareSchema(e,e,nx.schema({names:{RecipientEncryptedKeys:nD}}));S.assertSchema(t,this.className),this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,e=>new nE({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}}nx.CLASS_NAME="RecipientEncryptedKeys";let n$="version",nP="originator",nq="keyEncryptionAlgorithm",nK="recipientEncryptedKeys",nR="recipientCertificate",nJ="recipientPublicKey",nj=[n$,nP,"ukm",nq,nK];class nU extends y{constructor(e={}){super(),this.version=h.H$(e,n$,nU.defaultValues(n$)),this.originator=h.H$(e,nP,nU.defaultValues(nP)),"ukm"in e&&(this.ukm=h.H$(e,"ukm",nU.defaultValues("ukm"))),this.keyEncryptionAlgorithm=h.H$(e,nq,nU.defaultValues(nq)),this.recipientEncryptedKeys=h.H$(e,nK,nU.defaultValues(nK)),this.recipientCertificate=h.H$(e,nR,nU.defaultValues(nR)),this.recipientPublicKey=h.H$(e,nJ,nU.defaultValues(nJ)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case n$:return 0;case nP:return new nd;case"ukm":return new o.OctetString;case nq:return new T;case nK:return new nx;case nR:return new rj;case nJ:return null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case n$:return 0===t;case nP:return -1===t.variant&&"value"in t==!1;case"ukm":return t.isEqual(nU.defaultValues("ukm"));case nq:return""===t.algorithmId&&"algorithmParams"in t==!1;case nK:return 0===t.encryptedKeys.length;case nR:case nJ:return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[nd.schema(t.originator||{})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.OctetString({name:t.ukm||""})]}),T.schema(t.keyEncryptionAlgorithm||{}),nx.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){h.ze(e,nj);let t=o.compareSchema(e,e,nU.schema({names:{version:n$,originator:{names:{blockName:nP}},ukm:"ukm",keyEncryptionAlgorithm:{names:{blockName:nq}},recipientEncryptedKeys:{names:{blockName:nK}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.originator=new nd({schema:t.result.originator}),"ukm"in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new T({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new nx({schema:t.result.recipientEncryptedKeys})}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),this.ukm&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new o.Sequence({value:e})}toJSON(){let e={version:this.version,originator:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),recipientEncryptedKeys:this.recipientEncryptedKeys.toJSON()};return this.ukm&&(e.ukm=this.ukm.toJSON()),e}}nU.CLASS_NAME="KeyAgreeRecipientInfo";let nT="keyIdentifier",nL="date",nM="other",n_=[nT,nL,nM];class nW extends y{constructor(e={}){super(),this.keyIdentifier=h.H$(e,nT,nW.defaultValues(nT)),nL in e&&(this.date=h.H$(e,nL,nW.defaultValues(nL))),nM in e&&(this.other=h.H$(e,nM,nW.defaultValues(nM))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nT:return new o.OctetString;case nL:return new o.GeneralizedTime;case nM:return new nS;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nT:return t.isEqual(nW.defaultValues(nT));case nL:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case nM:return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.OctetString({name:t.keyIdentifier||""}),new o.GeneralizedTime({optional:!0,name:t.date||""}),nS.schema(t.other||{})]})}fromSchema(e){h.ze(e,n_);let t=o.compareSchema(e,e,nW.schema({names:{keyIdentifier:nT,date:nL,other:{names:{blockName:nM}}}}));S.assertSchema(t,this.className),this.keyIdentifier=t.result.keyIdentifier,nL in t.result&&(this.date=t.result.date),nM in t.result&&(this.other=new nS({schema:t.result.other}))}toSchema(){let e=[];return e.push(this.keyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new o.Sequence({value:e})}toJSON(){let e={keyIdentifier:this.keyIdentifier.toJSON()};return this.date&&(e.date=this.date),this.other&&(e.other=this.other.toJSON()),e}}nW.CLASS_NAME="KEKIdentifier";let nz="version",nF="kekid",nG="keyEncryptionAlgorithm",nQ="encryptedKey",nZ="preDefinedKEK",nX=[nz,nF,nG,nQ];class nY extends y{constructor(e={}){super(),this.version=h.H$(e,nz,nY.defaultValues(nz)),this.kekid=h.H$(e,nF,nY.defaultValues(nF)),this.keyEncryptionAlgorithm=h.H$(e,nG,nY.defaultValues(nG)),this.encryptedKey=h.H$(e,nQ,nY.defaultValues(nQ)),this.preDefinedKEK=h.H$(e,nZ,nY.defaultValues(nZ)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nz:return 0;case nF:return new nW;case nG:return new T;case nQ:return new o.OctetString;case nZ:return f;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===nY.defaultValues(nz);case nF:return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case nG:return""===t.algorithmId&&"algorithmParams"in t==!1;case nQ:return t.isEqual(nY.defaultValues(nQ));case nZ:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),nW.schema(t.kekid||{}),T.schema(t.keyEncryptionAlgorithm||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,nX);let t=o.compareSchema(e,e,nY.schema({names:{version:nz,kekid:{names:{blockName:nF}},keyEncryptionAlgorithm:{names:{blockName:nG}},encryptedKey:nQ}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.kekid=new nW({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new T({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new o.Sequence({value:[new o.Integer({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.kekid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}nY.CLASS_NAME="KEKRecipientInfo";let n1="version",n0="keyDerivationAlgorithm",n2="keyEncryptionAlgorithm",n3="encryptedKey",n4="password",n8=[n1,n0,n2,n3];class n5 extends y{constructor(e={}){super(),this.version=h.H$(e,n1,n5.defaultValues(n1)),n0 in e&&(this.keyDerivationAlgorithm=h.H$(e,n0,n5.defaultValues(n0))),this.keyEncryptionAlgorithm=h.H$(e,n2,n5.defaultValues(n2)),this.encryptedKey=h.H$(e,n3,n5.defaultValues(n3)),this.password=h.H$(e,n4,n5.defaultValues(n4)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case n1:return -1;case n0:case n2:return new T;case n3:return new o.OctetString;case n4:return f;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case n1:return -1===t;case n0:case n2:return""===t.algorithmId&&"algorithmParams"in t==!1;case n3:return t.isEqual(n5.defaultValues(n3));case n4:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Constructed({name:t.keyDerivationAlgorithm||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:T.schema().valueBlock.value}),T.schema(t.keyEncryptionAlgorithm||{}),new o.OctetString({name:t.encryptedKey||""})]})}fromSchema(e){h.ze(e,n8);let t=o.compareSchema(e,e,n5.schema({names:{version:n1,keyDerivationAlgorithm:n0,keyEncryptionAlgorithm:{names:{blockName:n2}},encryptedKey:n3}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,n0 in t.result&&(this.keyDerivationAlgorithm=new T({schema:new o.Sequence({value:t.result.keyDerivationAlgorithm.valueBlock.value})})),this.keyEncryptionAlgorithm=new T({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),this.keyDerivationAlgorithm&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new o.Sequence({value:e})}toJSON(){let e={version:this.version,keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()};return this.keyDerivationAlgorithm&&(e.keyDerivationAlgorithm=this.keyDerivationAlgorithm.toJSON()),e}}n5.CLASS_NAME="PasswordRecipientInfo";let n6="oriType",n9="oriValue",n7=[n6,n9];class le extends y{constructor(e={}){super(),this.oriType=h.H$(e,n6,le.defaultValues(n6)),this.oriValue=h.H$(e,n9,le.defaultValues(n9)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case n6:return"";case n9:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case n6:return""===t;case n9:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.oriType||""}),new o.Any({name:t.oriValue||""})]})}fromSchema(e){h.ze(e,n7);let t=o.compareSchema(e,e,le.schema({names:{oriType:n6,oriValue:n9}}));S.assertSchema(t,this.className),this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.oriType}),this.oriValue]})}toJSON(){let e={oriType:this.oriType};return le.compareWithDefault(n9,this.oriValue)||(e.oriValue=this.oriValue.toJSON()),e}}le.CLASS_NAME="OtherRecipientInfo";let lt="variant",la="value",ls=["blockName"];class lr extends y{constructor(e={}){super(),this.variant=h.H$(e,lt,lr.defaultValues(lt)),la in e&&(this.value=h.H$(e,la,lr.defaultValues(la))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lt:return -1;case la:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case lt:return t===lr.defaultValues(e);case la:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Choice({value:[ni.schema({names:{blockName:t.blockName||""}}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1},value:nU.schema().valueBlock.value}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2},value:nY.schema().valueBlock.value}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:3},value:n5.schema().valueBlock.value}),new o.Constructed({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:4},value:le.schema().valueBlock.value})]})}fromSchema(e){h.ze(e,ls);let t=o.compareSchema(e,e,lr.schema({names:{blockName:"blockName"}}));if(S.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new ni({schema:t.result.blockName});else{let e=new o.Sequence({value:t.result.blockName.valueBlock.value});switch(t.result.blockName.idBlock.tagNumber){case 1:this.variant=2,this.value=new nU({schema:e});break;case 2:this.variant=3,this.value=new nY({schema:e});break;case 3:this.variant=4,this.value=new n5({schema:e});break;case 4:this.variant=5,this.value=new le({schema:e});break;default:throw Error("Incorrect structure of RecipientInfo block")}}}toSchema(){p.assertEmpty(this.value,"value","RecipientInfo");let e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new o.Any}}toJSON(){let e={variant:this.variant};return this.value&&this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}lr.CLASS_NAME="RecipientInfo";let li="hashAlgorithm",ln="maskGenAlgorithm",ll="pSourceAlgorithm",lu=[li,ln,ll];class lo extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,li,lo.defaultValues(li)),this.maskGenAlgorithm=h.H$(e,ln,lo.defaultValues(ln)),this.pSourceAlgorithm=h.H$(e,ll,lo.defaultValues(ll)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case li:return new T({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null});case ln:return new T({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new T({algorithmId:"1.3.14.3.2.26",algorithmParams:new o.Null}).toSchema()});case ll:return new T({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new o.OctetString({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[T.schema(t.hashAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[T.schema(t.maskGenAlgorithm||{})]}),new o.Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[T.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){h.ze(e,lu);let t=o.compareSchema(e,e,lo.schema({names:{hashAlgorithm:{names:{blockName:li}},maskGenAlgorithm:{names:{blockName:ln}},pSourceAlgorithm:{names:{blockName:ll}}}}));S.assertSchema(t,this.className),li in t.result&&(this.hashAlgorithm=new T({schema:t.result.hashAlgorithm})),ln in t.result&&(this.maskGenAlgorithm=new T({schema:t.result.maskGenAlgorithm})),ll in t.result&&(this.pSourceAlgorithm=new T({schema:t.result.pSourceAlgorithm}))}toSchema(){let e=[];return this.hashAlgorithm.isEqual(lo.defaultValues(li))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(lo.defaultValues(ln))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(lo.defaultValues(ll))||e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new o.Sequence({value:e})}toJSON(){let e={};return this.hashAlgorithm.isEqual(lo.defaultValues(li))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(lo.defaultValues(ln))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(lo.defaultValues(ll))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}lo.CLASS_NAME="RSAESOAEPParams";let lc="keyInfo",lh="entityUInfo",lm="suppPubInfo",ld=[lc,lh,lm];class lf extends y{constructor(e={}){super(),this.keyInfo=h.H$(e,lc,lf.defaultValues(lc)),lh in e&&(this.entityUInfo=h.H$(e,lh,lf.defaultValues(lh))),this.suppPubInfo=h.H$(e,lm,lf.defaultValues(lm)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lc:return new T;case lh:case lm:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case lc:case lh:case lm:return t.isEqual(lf.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.keyInfo||{}),new o.Constructed({name:t.entityUInfo||"",idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new o.OctetString]}),new o.Constructed({name:t.suppPubInfo||"",idBlock:{tagClass:3,tagNumber:2},value:[new o.OctetString]})]})}fromSchema(e){h.ze(e,ld);let t=o.compareSchema(e,e,lf.schema({names:{keyInfo:{names:{blockName:lc}},entityUInfo:lh,suppPubInfo:lm}}));S.assertSchema(t,this.className),this.keyInfo=new T({schema:t.result.keyInfo}),lh in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){let e=[];return e.push(this.keyInfo.toSchema()),this.entityUInfo&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new o.Sequence({value:e})}toJSON(){let e={keyInfo:this.keyInfo.toJSON(),suppPubInfo:this.suppPubInfo.toJSON()};return this.entityUInfo&&(e.entityUInfo=this.entityUInfo.toJSON()),e}}lf.CLASS_NAME="ECCCMSSharedInfo";let lg="version",lp="originatorInfo",lS="recipientInfos",ly="encryptedContentInfo",lw="unprotectedAttrs",lv=[lg,lp,lS,ly,lw],lb={kdfAlgorithm:"SHA-512",kekEncryptionLength:256},lA={"P-256":256,"P-384":384,"P-521":528};class lk extends y{constructor(e={}){super(),this.version=h.H$(e,lg,lk.defaultValues(lg)),lp in e&&(this.originatorInfo=h.H$(e,lp,lk.defaultValues(lp))),this.recipientInfos=h.H$(e,lS,lk.defaultValues(lS)),this.encryptedContentInfo=h.H$(e,ly,lk.defaultValues(ly)),lw in e&&(this.unprotectedAttrs=h.H$(e,lw,lk.defaultValues(lw))),this.policy={disableSplit:!!e.disableSplit},e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lg:return 0;case lp:return new i0;case lS:return[];case ly:return new aA;case lw:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case lg:return t===lk.defaultValues(e);case lp:return 0===t.certs.certificates.length&&0===t.crls.crls.length;case lS:case lw:return 0===t.length;case ly:return aA.compareWithDefault("contentType",t.contentType)&&aA.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&aA.compareWithDefault("encryptedContent",t.encryptedContent);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||""}),new o.Constructed({name:t.originatorInfo||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:i0.schema().valueBlock.value}),new o.Set({value:[new o.Repeated({name:t.recipientInfos||"",value:lr.schema()})]}),aA.schema(t.encryptedContentInfo||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.unprotectedAttrs||"",value:G.schema()})]})]})}fromSchema(e){h.ze(e,lv);let t=o.compareSchema(e,e,lk.schema({names:{version:lg,originatorInfo:lp,recipientInfos:lS,encryptedContentInfo:{names:{blockName:ly}},unprotectedAttrs:lw}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,lp in t.result&&(this.originatorInfo=new i0({schema:new o.Sequence({value:t.result.originatorInfo.valueBlock.value})})),this.recipientInfos=Array.from(t.result.recipientInfos,e=>new lr({schema:e})),this.encryptedContentInfo=new aA({schema:t.result.encryptedContentInfo}),lw in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new G({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),this.originatorInfo&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new o.Set({value:Array.from(this.recipientInfos,e=>e.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,recipientInfos:Array.from(this.recipientInfos,e=>e.toJSON()),encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.originatorInfo&&(e.originatorInfo=this.originatorInfo.toJSON()),this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}addRecipientByCertificate(e,t,a,s=aM(!0)){let r=Object.assign({useOAEP:!0,oaepHashAlgorithm:"SHA-512"},lb,t||{});if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))a=1;else if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))a=2;else throw Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);switch(a){case 1:{let t,a;if(!0===r.useOAEP){t=s.getOIDByAlgorithm({name:"RSA-OAEP"},!0,"keyEncryptionAlgorithm");let e=s.getOIDByAlgorithm({name:r.oaepHashAlgorithm},!0,"RSAES-OAEP-params"),i=new T({algorithmId:e,algorithmParams:new o.Null}),n=new lo({hashAlgorithm:i,maskGenAlgorithm:new T({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:i.toSchema()})});a=n.toSchema()}else{if(""===(t=s.getOIDByAlgorithm({name:"RSAES-PKCS1-v1_5"})))throw Error("Can not find OID for RSAES-PKCS1-v1_5");a=new o.Null}let i=new ni({version:0,rid:new i8({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new T({algorithmId:t,algorithmParams:a}),recipientCertificate:e});this.recipientInfos.push(new lr({variant:1,value:i}))}break;case 2:{let t=new nV({variant:1,value:new i8({issuer:e.issuer,serialNumber:e.serialNumber})});this._addKeyAgreeRecipientInfo(t,r,{recipientCertificate:e},s)}break;default:throw Error(`Unknown "variant" value: ${a}`)}return!0}addRecipientByPreDefinedData(e,t={},a,s=aM(!0)){if(g.assert(e,"preDefinedData","ArrayBuffer"),!e.byteLength)throw Error("Pre-defined data could have zero length");if(!t.keyIdentifier){let e=new ArrayBuffer(16),a=new Uint8Array(e);s.getRandomValues(a),t.keyIdentifier=e}switch(t.hmacHashAlgorithm||(t.hmacHashAlgorithm="SHA-512"),void 0===t.iterationCount&&(t.iterationCount=2048),t.keyEncryptionAlgorithm||(t.keyEncryptionAlgorithm={name:"AES-KW",length:256}),t.keyEncryptionAlgorithmParams||(t.keyEncryptionAlgorithmParams=new o.Null),a){case 1:{let a=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),r=new nY({version:4,kekid:new nW({keyIdentifier:new o.OctetString({valueHex:t.keyIdentifier})}),keyEncryptionAlgorithm:new T({algorithmId:a,algorithmParams:t.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new lr({variant:3,value:r}))}break;case 2:{let a=s.getOIDByAlgorithm({name:"PBKDF2"},!0,"keyDerivationAlgorithm"),r=new ArrayBuffer(64),i=new Uint8Array(r);s.getRandomValues(i);let n=s.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),l=new ax({salt:new o.OctetString({valueHex:r}),iterationCount:t.iterationCount,prf:new T({algorithmId:n,algorithmParams:new o.Null})}),u=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),c=new n5({version:0,keyDerivationAlgorithm:new T({algorithmId:a,algorithmParams:l.toSchema()}),keyEncryptionAlgorithm:new T({algorithmId:u,algorithmParams:t.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new lr({variant:4,value:c}))}break;default:throw Error(`Unknown value for "variant": ${a}`)}}addRecipientByKeyIdentifier(e,t,a,s=aM(!0)){let r=Object.assign({},lb,a||{}),i=new nV({variant:2,value:new nA({subjectKeyIdentifier:new o.OctetString({valueHex:t})})});this._addKeyAgreeRecipientInfo(i,r,{recipientPublicKey:e},s)}_addKeyAgreeRecipientInfo(e,t,a,s=aM(!0)){let r=new nE({rid:e}),i=s.getOIDByAlgorithm({name:"AES-KW",length:t.kekEncryptionLength},!0,"keyEncryptionAlgorithm"),n=new T({algorithmId:i}),l=s.getOIDByAlgorithm({name:"ECDH",kdf:t.kdfAlgorithm},!0,"KeyAgreeRecipientInfo"),u=new ArrayBuffer(64),c=new Uint8Array(u);s.getRandomValues(c);let h={version:3,ukm:new o.OctetString({valueHex:u}),keyEncryptionAlgorithm:new T({algorithmId:l,algorithmParams:n.toSchema()}),recipientEncryptedKeys:new nx({encryptedKeys:[r]})},m=new nU(Object.assign(h,a));this.recipientInfos.push(new lr({variant:2,value:m}))}async encrypt(e,t,a=aM(!0)){let s=new ArrayBuffer(16),r=new Uint8Array(s);a.getRandomValues(r);let i=new Uint8Array(t),n=a.getOIDByAlgorithm(e,!0,"contentEncryptionAlgorithm"),l=await a.generateKey(e,!0,["encrypt"]),u=await a.encrypt({name:e.name,iv:r},l,i),c=await a.exportKey("raw",l);this.version=2,this.encryptedContentInfo=new aA({disableSplit:this.policy.disableSplit,contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new T({algorithmId:n,algorithmParams:new o.OctetString({valueHex:s})}),encryptedContent:new o.OctetString({valueHex:u})});let h=async e=>{let t,s;let r=this.recipientInfos[e].value;if(r.recipientPublicKey)t=r.recipientPublicKey.algorithm.namedCurve,s=r.recipientPublicKey;else if(r.recipientCertificate){let i=r.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(i.constructor.blockName()!==o.ObjectIdentifier.blockName())throw Error(`Incorrect "recipientCertificate" for index ${e}`);let n=i.valueBlock.toString();switch(n){case"1.2.840.10045.3.1.7":t="P-256";break;case"1.3.132.0.34":t="P-384";break;case"1.3.132.0.35":t="P-521";break;default:throw Error(`Incorrect curve OID for index ${e}`)}s=await r.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:t},usages:[]}},a)}else throw Error("Unsupported RecipientInfo");let i=lA[t],n=await a.generateKey({name:"ECDH",namedCurve:t},!0,["deriveBits"]),u=await a.exportKey("spki",n.publicKey),c=await a.deriveBits({name:"ECDH",public:s},n.privateKey,i),h=new T({schema:r.keyEncryptionAlgorithm.algorithmParams}),m=a.getAlgorithmByOID(h.algorithmId,!0,"aesKWAlgorithm"),d=m.length,f=new ArrayBuffer(4),g=new Uint8Array(f);for(let e=3;e>=0;e--)g[e]=d,d>>=8;let p=new lf({keyInfo:new T({algorithmId:h.algorithmId}),entityUInfo:r.ukm,suppPubInfo:new o.OctetString({valueHex:f})}),S=p.toSchema().toBER(!1),y=a.getAlgorithmByOID(r.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm"),w=await aW(y.kdf,c,m.length,S,a),v=await a.importKey("raw",w,{name:"AES-KW"},!0,["wrapKey"]),b=await a.wrapKey("raw",l,v,{name:"AES-KW"}),A=new nd;return A.variant=3,A.value=no.fromBER(u),r.originator=A,r.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new o.OctetString({valueHex:b}),{ecdhPrivateKey:n.privateKey}},m=async e=>{let t=this.recipientInfos[e].value,s=a.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===s.name){let e=t.keyEncryptionAlgorithm.algorithmParams,r=new lo({schema:e});if(s.hash=a.getAlgorithmByOID(r.hashAlgorithm.algorithmId),"name"in s.hash==!1)throw Error(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`)}try{let e=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:s,usages:["encrypt","wrapKey"]}},a),r=await a.encrypt(e.algorithm,e,c);t.encryptedKey=new o.OctetString({valueHex:r})}catch{}},d=async e=>{let t=this.recipientInfos[e].value,s=a.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),r=await a.importKey("raw",new Uint8Array(t.preDefinedKEK),s,!0,["wrapKey"]),i=await a.wrapKey("raw",l,r,s);t.encryptedKey=new o.OctetString({valueHex:i})},f=async e=>{let t;let s=this.recipientInfos[e].value;if(!s.keyDerivationAlgorithm)throw Error('Please append encoded "keyDerivationAlgorithm"');if(!s.keyDerivationAlgorithm.algorithmParams)throw Error('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new ax({schema:s.keyDerivationAlgorithm.algorithmParams})}catch(e){throw Error('Incorrectly encoded "keyDerivationAlgorithm"')}let r=new Uint8Array(s.password),i=await a.importKey("raw",r,"PBKDF2",!1,["deriveKey"]),n=a.getAlgorithmByOID(s.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),u="SHA-1";if(t.prf){let e=a.getAlgorithmByOID(t.prf.algorithmId,!0,"prfAlgorithm");u=e.hash.name}let c=new Uint8Array(t.salt.valueBlock.valueHex),h=t.iterationCount,m=await a.deriveKey({name:"PBKDF2",hash:{name:u},salt:c,iterations:h},i,n,!0,["wrapKey"]),d=await a.wrapKey("raw",l,m,n);s.encryptedKey=new o.OctetString({valueHex:d})},g=[];for(let e=0;e<this.recipientInfos.length;e++)switch(this.recipientInfos[e].variant){case 1:g.push(await m(e));break;case 2:g.push(await h(e));break;case 3:g.push(await d(e));break;case 4:g.push(await f(e));break;default:throw Error(`Unknown recipient type in array with index ${e}`)}return g}async decrypt(e,t,a=aM(!0)){let s;let r=t||{};if(e+1>this.recipientInfos.length)throw Error(`Maximum value for "index" is: ${this.recipientInfos.length-1}`);let i=async e=>{let t,s,i,n;let l=this.recipientInfos[e].value,u=l.originator;if(r.recipientCertificate){let a=r.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(a.constructor.blockName()!==o.ObjectIdentifier.blockName())throw Error(`Incorrect "recipientCertificate" for index ${e}`);t=a.valueBlock.toString()}else if(u.value.algorithm.algorithmParams){let a=u.value.algorithm.algorithmParams;if(a.constructor.blockName()!==o.ObjectIdentifier.blockName())throw Error(`Incorrect originator for index ${e}`);t=a.valueBlock.toString()}else throw Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');if(!r.recipientPrivateKey)throw Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');switch(t){case"1.2.840.10045.3.1.7":s="P-256",i=256;break;case"1.3.132.0.34":s="P-384",i=384;break;case"1.3.132.0.35":s="P-521",i=528;break;default:throw Error(`Incorrect curve OID for index ${e}`)}let h=a;c.vJ.isBufferSource(r.recipientPrivateKey)?n=await a.importKey("pkcs8",r.recipientPrivateKey,{name:"ECDH",namedCurve:s},!0,["deriveBits"]):(n=r.recipientPrivateKey,"crypto"in r&&r.crypto&&(h=r.crypto.subtle)),"algorithmParams"in u.value.algorithm==!1&&(u.value.algorithm.algorithmParams=new o.ObjectIdentifier({value:t}));let m=u.value.toSchema().toBER(!1),d=await a.importKey("spki",m,{name:"ECDH",namedCurve:s},!0,[]),f=await h.deriveBits({name:"ECDH",public:d},n,i);async function g(e){e=e||!1;let t=new T({schema:l.keyEncryptionAlgorithm.algorithmParams}),s=a.getAlgorithmByOID(t.algorithmId,!0,"kwAlgorithm"),r=s.length,i=new ArrayBuffer(4),n=new Uint8Array(i);for(let e=3;e>=0;e--)n[e]=r,r>>=8;let u={algorithmId:t.algorithmId};e&&(u.algorithmParams=new o.Null);let c=new lf({keyInfo:new T(u),entityUInfo:l.ukm,suppPubInfo:new o.OctetString({valueHex:i})}),h=c.toSchema().toBER(!1),m=a.getAlgorithmByOID(l.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm");if(!m.name)throw Error(`Incorrect OID for key encryption algorithm: ${l.keyEncryptionAlgorithm.algorithmId}`);return aW(m.kdf,f,s.length,h,a)}let p=await g(),S=async e=>a.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),y=await S(p),w=async e=>{let t=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,s=a.getAlgorithmByOID(t,!0,"contentEncryptionAlgorithm");return a.unwrapKey("raw",l.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView,e,{name:"AES-KW"},s,!0,["decrypt"])};try{return await w(y)}catch{let e=await g(!0),t=await S(e);return w(t)}},n=async e=>{let t;let s=this.recipientInfos[e].value;if(!r.recipientPrivateKey)throw Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');let i=a.getAlgorithmByOID(s.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===i.name){let e=s.keyEncryptionAlgorithm.algorithmParams,t=new lo({schema:e});if(i.hash=a.getAlgorithmByOID(t.hashAlgorithm.algorithmId),"name"in i.hash==!1)throw Error(`Incorrect OID for hash algorithm: ${t.hashAlgorithm.algorithmId}`)}let n=a;c.vJ.isBufferSource(r.recipientPrivateKey)?t=await a.importKey("pkcs8",r.recipientPrivateKey,i,!0,["decrypt"]):(t=r.recipientPrivateKey,"crypto"in r&&r.crypto&&(n=r.crypto.subtle));let l=await n.decrypt(t.algorithm,t,s.encryptedKey.valueBlock.valueHexView),u=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,o=a.getAlgorithmByOID(u,!0,"contentEncryptionAlgorithm");if("name"in o==!1)throw Error(`Incorrect "contentEncryptionAlgorithm": ${u}`);return a.importKey("raw",l,o,!0,["decrypt"])},l=async e=>{let t=this.recipientInfos[e].value;if(!r.preDefinedData)throw Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');let s=a.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),i=await a.importKey("raw",r.preDefinedData,s,!0,["unwrapKey"]),n=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,l=a.getAlgorithmByOID(n,!0,"contentEncryptionAlgorithm");if(!l.name)throw Error(`Incorrect "contentEncryptionAlgorithm": ${n}`);return a.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,i,s,l,!0,["decrypt"])},u=async e=>{let t;let s=this.recipientInfos[e].value;if(!r.preDefinedData)throw Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if(!s.keyDerivationAlgorithm)throw Error('Please append encoded "keyDerivationAlgorithm"');if(!s.keyDerivationAlgorithm.algorithmParams)throw Error('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new ax({schema:s.keyDerivationAlgorithm.algorithmParams})}catch(e){throw Error('Incorrectly encoded "keyDerivationAlgorithm"')}let i=await a.importKey("raw",r.preDefinedData,"PBKDF2",!1,["deriveKey"]),n=a.getAlgorithmByOID(s.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm"),l=t.prf?a.getAlgorithmByOID(t.prf.algorithmId,!0,"prfAlgorithm").hash.name:"SHA-1",u=new Uint8Array(t.salt.valueBlock.valueHex),o=t.iterationCount,c=await a.deriveKey({name:"PBKDF2",hash:{name:l},salt:u,iterations:o},i,n,!0,["unwrapKey"]),h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=a.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm");return a.unwrapKey("raw",s.encryptedKey.valueBlock.valueHexView,c,n,m,!0,["decrypt"])};switch(this.recipientInfos[e].variant){case 1:s=await n(e);break;case 2:s=await i(e);break;case 3:s=await l(e);break;case 4:s=await u(e);break;default:throw Error(`Unknown recipient type in array with index ${e}`)}let h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=a.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm"),d=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,f=new Uint8Array(d);if(!this.encryptedContentInfo.encryptedContent)throw Error("Required property `encryptedContent` is empty");let g=this.encryptedContentInfo.getEncryptedContent();return a.decrypt({name:m.name,iv:f},s,g)}}lk.CLASS_NAME="EnvelopedData";let lC="safeContents",lN="parsedValue",lV="contentInfos";class lI extends y{constructor(e={}){super(),this.safeContents=h.H$(e,lC,lI.defaultValues(lC)),lN in e&&(this.parsedValue=h.H$(e,lN,lI.defaultValues(lN))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lC:return[];case lN:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case lC:return 0===t.length;case lN:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Repeated({name:t.contentInfos||"",value:rl.schema()})]})}fromSchema(e){h.ze(e,[lV]);let t=o.compareSchema(e,e,lI.schema({names:{contentInfos:lV}}));S.assertSchema(t,this.className),this.safeContents=Array.from(t.result.contentInfos,e=>new rl({schema:e}))}toSchema(){return new o.Sequence({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}async parseInternalValues(e,t=aM(!0)){if(p.assert(e,lC),g.assert(e.safeContents,lC,"Array"),e.safeContents.length!==this.safeContents.length)throw new g('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');for(let[a,s]of(this.parsedValue={safeContents:[]},this.safeContents.entries())){let r=e.safeContents[a],i=`parameters.safeContents[${a}]`;switch(s.contentType){case eS:{g.assert(s.content,"this.safeContents[j].content",o.OctetString);let e=s.content.getValue();this.parsedValue.safeContents.push({privacyMode:0,value:iq.fromBER(e)})}break;case ew:{let e=new lk({schema:s.content});p.assert(i,r,"recipientCertificate","recipientKey");let a=r.recipientCertificate,n=r.recipientKey,l=await e.decrypt(0,{recipientCertificate:a,recipientPrivateKey:n},t);this.parsedValue.safeContents.push({privacyMode:2,value:iq.fromBER(l)})}break;case ev:{let e=new iw({schema:s.content});p.assert(i,r,"password");let a=r.password,n=await e.decrypt({password:a},t);this.parsedValue.safeContents.push({privacyMode:1,value:iq.fromBER(n)})}break;default:throw Error(`Unknown "contentType" for AuthenticatedSafe: " ${s.contentType}`)}}}async makeInternalValues(e,t=aM(!0)){if(!this.parsedValue)throw Error('Please run "parseValues" first or add "parsedValue" manually');if(g.assert(this.parsedValue,"this.parsedValue","object"),g.assert(this.parsedValue.safeContents,"this.parsedValue.safeContents","Array"),g.assert(e,"parameters","object"),p.assert(e,"safeContents"),g.assert(e.safeContents,"parameters.safeContents","Array"),e.safeContents.length!==this.parsedValue.safeContents.length)throw new g('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');for(let[a,s]of(this.safeContents=[],this.parsedValue.safeContents.entries()))switch(p.assert("content",s,"privacyMode","value"),g.assert(s.value,"content.value",iq),s.privacyMode){case 0:{let e=s.value.toSchema().toBER(!1);this.safeContents.push(new rl({contentType:"1.2.840.113549.1.7.1",content:new o.OctetString({valueHex:e})}))}break;case 1:{let r=new iw,i=e.safeContents[a];i.contentToEncrypt=s.value.toSchema().toBER(!1),await r.encrypt(i,t),this.safeContents.push(new rl({contentType:"1.2.840.113549.1.7.6",content:r.toSchema()}))}break;case 2:{let r=new lk,i=s.value.toSchema().toBER(!1),n=e.safeContents[a];switch(p.assert(`parameters.safeContents[${a}]`,n,"encryptingCertificate","encryptionAlgorithm"),!0){case"aes-cbc"===n.encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===n.encryptionAlgorithm.name.toLowerCase():break;default:throw Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${n.encryptionAlgorithm}`)}switch(!0){case 128===n.encryptionAlgorithm.length:case 192===n.encryptionAlgorithm.length:case 256===n.encryptionAlgorithm.length:break;default:throw Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${n.encryptionAlgorithm.length}`)}let l=n.encryptionAlgorithm;r.addRecipientByCertificate(n.encryptingCertificate,{},void 0,t),await r.encrypt(l,i,t),this.safeContents.push(new rl({contentType:"1.2.840.113549.1.7.3",content:r.toSchema()}))}break;default:throw Error(`Incorrect value for "content.privacyMode": ${s.privacyMode}`)}return this}}lI.CLASS_NAME="AuthenticatedSafe";let lB="hashAlgorithm",lE="issuerNameHash",lH="issuerKeyHash",lD="serialNumber",lO=[lB,lE,lH,lD];class lx extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,lB,lx.defaultValues(lB)),this.issuerNameHash=h.H$(e,lE,lx.defaultValues(lE)),this.issuerKeyHash=h.H$(e,lH,lx.defaultValues(lH)),this.serialNumber=h.H$(e,lD,lx.defaultValues(lD)),e.schema&&this.fromSchema(e.schema)}static async create(e,t,a=aM(!0)){let s=new lx;return await s.createForCertificate(e,t,a),s}static defaultValues(e){switch(e){case lB:return new T;case lE:case lH:return new o.OctetString;case lD:return new o.Integer;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case lB:return""===t.algorithmId&&"algorithmParams"in t==!1;case lE:case lH:case lD:return t.isEqual(lx.defaultValues(lD));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||""}}),new o.OctetString({name:t.issuerNameHash||""}),new o.OctetString({name:t.issuerKeyHash||""}),new o.Integer({name:t.serialNumber||""})]})}fromSchema(e){h.ze(e,lO);let t=o.compareSchema(e,e,lx.schema({names:{hashAlgorithm:lB,issuerNameHash:lE,issuerKeyHash:lH,serialNumber:lD}}));S.assertSchema(t,this.className),this.hashAlgorithm=new T({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new o.Sequence({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return!!(this.hashAlgorithm.algorithmId===e.hashAlgorithm.algorithmId&&c.vJ.isEqual(this.issuerNameHash.valueBlock.valueHexView,e.issuerNameHash.valueBlock.valueHexView)&&c.vJ.isEqual(this.issuerKeyHash.valueBlock.valueHexView,e.issuerKeyHash.valueBlock.valueHexView)&&this.serialNumber.isEqual(e.serialNumber))}async createForCertificate(e,t,a=aM(!0)){p.assert(t,lB,"issuerCertificate");let s=a.getOIDByAlgorithm({name:t.hashAlgorithm},!0,"hashAlgorithm");this.hashAlgorithm=new T({algorithmId:s,algorithmParams:new o.Null});let r=t.issuerCertificate;this.serialNumber=e.serialNumber;let i=await a.digest({name:t.hashAlgorithm},r.subject.toSchema().toBER(!1));this.issuerNameHash=new o.OctetString({valueHex:i});let n=r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView,l=await a.digest({name:t.hashAlgorithm},n);this.issuerKeyHash=new o.OctetString({valueHex:l})}}lx.CLASS_NAME="CertID";let l$="certID",lP="certStatus",lq="thisUpdate",lK="nextUpdate",lR="singleExtensions",lJ=[l$,lP,lq,lK,lR];class lj extends y{constructor(e={}){super(),this.certID=h.H$(e,l$,lj.defaultValues(l$)),this.certStatus=h.H$(e,lP,lj.defaultValues(lP)),this.thisUpdate=h.H$(e,lq,lj.defaultValues(lq)),lK in e&&(this.nextUpdate=h.H$(e,lK,lj.defaultValues(lK))),lR in e&&(this.singleExtensions=h.H$(e,lR,lj.defaultValues(lR))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case l$:return new lx;case lP:return{};case lq:case lK:return new Date(0,0,0);case lR:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case l$:return lx.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&lx.compareWithDefault("issuerNameHash",t.issuerNameHash)&&lx.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&lx.compareWithDefault("serialNumber",t.serialNumber);case lP:return 0===Object.keys(t).length;case lq:case lK:return t===lj.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[lx.schema(t.certID||{}),new o.Choice({value:[new o.Primitive({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:0}}),new o.Constructed({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:1},value:[new o.GeneralizedTime,new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Enumerated]})]}),new o.Primitive({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new o.GeneralizedTime({name:t.thisUpdate||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.GeneralizedTime({name:t.nextUpdate||""})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[sd.schema(t.singleExtensions||{})]})]})}fromSchema(e){h.ze(e,lJ);let t=o.compareSchema(e,e,lj.schema({names:{certID:{names:{blockName:l$}},certStatus:lP,thisUpdate:lq,nextUpdate:lK,singleExtensions:{names:{blockName:lR}}}}));S.assertSchema(t,this.className),this.certID=new lx({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),lK in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),lR in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,e=>new sc({schema:e})))}toSchema(){let e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new o.GeneralizedTime({valueDate:this.thisUpdate})),this.nextUpdate&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.GeneralizedTime({valueDate:this.nextUpdate})]})),this.singleExtensions&&e.push(new o.Sequence({value:Array.from(this.singleExtensions,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return this.nextUpdate&&(e.nextUpdate=this.nextUpdate),this.singleExtensions&&(e.singleExtensions=Array.from(this.singleExtensions,e=>e.toJSON())),e}}lj.CLASS_NAME="SingleResponse";let lU="version",lT="responderID",lL="producedAt",lM="responses",l_="responseExtensions",lW="ResponseData",lz=`${lW}.${lU}`,lF=`${lW}.${lT}`,lG=`${lW}.${lL}`,lQ=`${lW}.${lM}`,lZ=`${lW}.${l_}`,lX=[lW,lz,lF,lG,lQ,lZ];class lY extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",lY.defaultValues("tbs"))),lU in e&&(this.version=h.H$(e,lU,lY.defaultValues(lU))),this.responderID=h.H$(e,lT,lY.defaultValues(lT)),this.producedAt=h.H$(e,lL,lY.defaultValues(lL)),this.responses=h.H$(e,lM,lY.defaultValues(lM)),l_ in e&&(this.responseExtensions=h.H$(e,l_,lY.defaultValues(l_))),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case lU:return 0;case"tbs":return f;case lT:return{};case lL:return new Date(0,0,0);case lM:case l_:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"tbs":return 0===t.byteLength;case lT:return 0===Object.keys(t).length;case lL:return t===lY.defaultValues(e);case lM:case l_:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||lW,value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.version||lz})]}),new o.Choice({value:[new o.Constructed({name:t.responderID||lF,idBlock:{tagClass:3,tagNumber:1},value:[N.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new o.Constructed({name:t.responderID||lF,idBlock:{tagClass:3,tagNumber:2},value:[new o.OctetString({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new o.GeneralizedTime({name:t.producedAt||lG}),new o.Sequence({value:[new o.Repeated({name:lQ,value:lj.schema(t.response||{})})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[sd.schema(t.extensions||{names:{blockName:lZ}})]})]})}fromSchema(e){h.ze(e,lX);let t=o.compareSchema(e,e,lY.schema());S.assertSchema(t,this.className),this.tbsView=t.result.ResponseData.valueBeforeDecodeView,lz in t.result&&(this.version=t.result[lz].valueBlock.valueDec),1===t.result[lF].idBlock.tagNumber?this.responderID=new N({schema:t.result[lF].valueBlock.value[0]}):this.responderID=t.result[lF].valueBlock.value[0],this.producedAt=t.result[lG].toDate(),this.responses=Array.from(t.result[lQ],e=>new lj({schema:e})),lZ in t.result&&(this.responseExtensions=Array.from(t.result[lZ].valueBlock.value,e=>new sc({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return lY.schema();let e=o.fromBER(this.tbsView);S.assert(e,"TBS Response Data"),t=e.result}else{let e=[];lU in this&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({value:this.version})]})),this.responderID instanceof N?e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new o.GeneralizedTime({valueDate:this.producedAt})),e.push(new o.Sequence({value:Array.from(this.responses,e=>e.toSchema())})),this.responseExtensions&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new o.Sequence({value:Array.from(this.responseExtensions,e=>e.toSchema())})]})),t=new o.Sequence({value:e})}return t}toJSON(){let e={};return lU in this&&(e.version=this.version),this.responderID&&(e.responderID=this.responderID),this.producedAt&&(e.producedAt=this.producedAt),this.responses&&(e.responses=Array.from(this.responses,e=>e.toJSON())),this.responseExtensions&&(e.responseExtensions=Array.from(this.responseExtensions,e=>e.toJSON())),e}}lY.CLASS_NAME="ResponseData";let l1="trustedCerts",l0="certs",l2="crls",l3="ocsps",l4="checkDate",l8="findOrigin",l5="findIssuer";(r=l||(l={}))[r.unknown=-1]="unknown",r[r.success=0]="success",r[r.noRevocation=11]="noRevocation",r[r.noPath=60]="noPath",r[r.noValidPath=97]="noValidPath";class l6 extends Error{constructor(e,t){super(t),this.name=l6.NAME,this.code=e,this.message=t}}l6.NAME="ChainValidationError";class l9{constructor(e={}){this.trustedCerts=h.H$(e,l1,this.defaultValues(l1)),this.certs=h.H$(e,l0,this.defaultValues(l0)),this.crls=h.H$(e,l2,this.defaultValues(l2)),this.ocsps=h.H$(e,l3,this.defaultValues(l3)),this.checkDate=h.H$(e,l4,this.defaultValues(l4)),this.findOrigin=h.H$(e,l8,this.defaultValues(l8)),this.findIssuer=h.H$(e,l5,this.defaultValues(l5))}static defaultFindOrigin(e,t){for(let a of(0===e.tbsView.byteLength&&(e.tbsView=new Uint8Array(e.encodeTBS().toBER())),t.certs))if(0===a.tbsView.byteLength&&(a.tbsView=new Uint8Array(a.encodeTBS().toBER())),c.vJ.isEqual(e.tbsView,a.tbsView))return"Intermediate Certificates";for(let a of t.trustedCerts)if(0===a.tbsView.byteLength&&(a.tbsView=new Uint8Array(a.encodeTBS().toBER())),c.vJ.isEqual(e.tbsView,a.tbsView))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t,a=aM(!0)){let s=[],r=null,i=null,n=null;if(e.subject.isEqual(e.issuer))try{let t=await e.verify(void 0,a);if(t)return[e]}catch(e){}if(e.extensions){for(let t of e.extensions)if(t.extnID===ef&&t.parsedValue instanceof eE){t.parsedValue.keyIdentifier?r=t.parsedValue.keyIdentifier:(t.parsedValue.authorityCertIssuer&&(i=t.parsedValue.authorityCertIssuer),t.parsedValue.authorityCertSerialNumber&&(n=t.parsedValue.authorityCertSerialNumber));break}}function l(t){if(null!==r&&t.extensions){let e=!1;for(let a of t.extensions)if("2.5.29.14"===a.extnID&&a.parsedValue){e=!0,c.vJ.isEqual(a.parsedValue.valueBlock.valueHex,r.valueBlock.valueHexView)&&s.push(t);break}if(e)return}let a=!1;null!==n&&(a=t.serialNumber.isEqual(n)),null!==i?t.subject.isEqual(i)&&a&&s.push(t):e.issuer.isEqual(t.subject)&&s.push(t)}for(let e of t.trustedCerts)l(e);for(let e of t.certs)l(e);for(let t=0;t<s.length;t++)try{let r=await e.verify(s[t],a);!1===r&&s.splice(t,1)}catch(e){s.splice(t,1)}return s}defaultValues(e){switch(e){case l1:case l0:case l2:case l3:return[];case l4:return new Date;case l8:return l9.defaultFindOrigin;case l5:return this.defaultFindIssuer;default:throw Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(e=!1,t=aM(!0)){let a;let s=[],r=async(e,t)=>{let a=[];if(function(e,t){for(let a=0;a<t.length;a++)if(c.vJ.isEqual(e.tbsView,t[a].tbsView))return!0;return!1}(e,this.trustedCerts))return[[e]];let s=await this.findIssuer(e,this,t);if(0===s.length)throw Error("No valid certificate paths found");for(let i=0;i<s.length;i++){if(c.vJ.isEqual(s[i].tbsView,e.tbsView)){a.push([s[i]]);continue}let n=await r(s[i],t);for(let e=0;e<n.length;e++){let t=n[e].slice();t.splice(0,0,s[i]),function(e){let t=!0;for(let a=0;a<e.length;a++){for(let s=0;s<e.length;s++)if(s!==a&&e[a]===e[s]){t=!1;break}if(!t)break}return t}(t)?a.push(t):a.push(n[e])}}return a},i=async e=>{let a=[],r=[],i=[];if(a.push(...s.filter(t=>e.issuer.isEqual(t.subject))),0===a.length)return{status:1,statusMessage:"No certificate's issuers"};if(r.push(...this.crls.filter(t=>t.issuer.isEqual(e.issuer))),0===r.length)return{status:2,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<r.length;e++){let s=r[e];if(!s.nextUpdate||!(s.nextUpdate.value<this.checkDate))for(let s=0;s<a.length;s++)try{let n=await r[e].verify({issuerCertificate:a[s]},t);if(n){i.push({crl:r[e],certificate:a[s]});break}}catch(e){}}return i.length?{status:0,statusMessage:"",result:i}:{status:3,statusMessage:"No valid CRLs found"}},n=async(e,a)=>{let s=t.getAlgorithmByOID(e.signatureAlgorithm.algorithmId);if(!s.name||!s.hash)return 1;for(let s=0;s<this.ocsps.length;s++){let r=this.ocsps[s],i=await r.getCertificateStatus(e,a,t);if(i.isForCertificate){if(0===i.status)return 0;return 1}}return 2};async function u(e,t=!1){let a=!1,s=!1,r=!1,i=!1;if(e.extensions){for(let t=0;t<e.extensions.length;t++){let n=e.extensions[t];if(n.critical&&!n.parsedValue)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${n.extnID}`};if("2.5.29.15"===n.extnID){r=!0;let e=new Uint8Array(n.parsedValue.valueBlock.valueHex);(4&e[0])==4&&(s=!0),(2&e[0])==2&&(i=!0)}n.extnID===ei&&"cA"in n.parsedValue&&!0===n.parsedValue.cA&&(a=!0)}if(!0===s&&!1===a)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'};if(!0===r&&!0===a&&!1===s)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===a&&!0===r&&t&&!1===i)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===a?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:""}}let o=async(t,a)=>{for(let e=0;e<t.length;e++)if(t[e].notBefore.value>a||t[e].notAfter.value<a)return{result:!1,resultCode:8,resultMessage:"The certificate is either not yet valid or expired"};if(t.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let e=t.length-2;e>=0;e--)if(!1===t[e].issuer.isEqual(t[e].subject)&&!1===t[e].issuer.isEqual(t[e+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==this.crls.length||0!==this.ocsps.length)for(let a=0;a<t.length-1;a++){let s=2,r={status:0,statusMessage:""};if(0!==this.ocsps.length)switch(s=await n(t[a],t[a+1])){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==this.crls.length){if(0===(r=await i(t[a])).status&&r.result)for(let e=0;e<r.result.length;e++){let s=r.result[e].crl.isCertificateRevoked(t[a]);if(s)return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};let i=await u(r.result[e].certificate,!0);if(!1===i.result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}else if(!1===e)throw new l6(l.noRevocation,`No revocation values found for one of certificates: ${r.statusMessage}`)}else if(2===s)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"};if(2===s&&2===r.status&&e){let e=t[a+1],s=!1;if(e.extensions)for(let t of e.extensions)switch(t.extnID){case eo:case ec:case ep:s=!0}if(s)throw new l6(l.noRevocation,`No revocation values found for one of certificates: ${r.statusMessage}`)}}for(let[e,a]of t.entries()){if(!e)continue;let t=await u(a);if(!t.result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}};s.push(...this.trustedCerts),s.push(...this.certs);for(let e=0;e<s.length;e++)for(let t=0;t<s.length;t++)if(e!==t&&c.vJ.isEqual(s[e].tbsView,s[t].tbsView)){s.splice(t,1),e=0;break}let h=s[s.length-1],m=[h];if(0===(a=await r(h,t)).length)throw new l6(l.noPath,"Unable to find certificate path");for(let e=0;e<a.length;e++){let t=!1;for(let s=0;s<a[e].length;s++){let r=a[e][s];for(let e=0;e<this.trustedCerts.length;e++)if(c.vJ.isEqual(r.tbsView,this.trustedCerts[e].tbsView)){t=!0;break}if(t)break}t||(a.splice(e,1),e=0)}if(0===a.length)throw new l6(l.noValidPath,"No valid certificate paths found");let d=a[0].length,f=0;for(let e=0;e<a.length;e++)a[e].length<d&&(d=a[e].length,f=e);for(let e=0;e<a[f].length;e++)m.push(a[f][e]);if(!1===(a=await o(m,this.checkDate)).result)throw a;return m}async verify(e={},t=aM(!0)){function a(e,t){let a=w(e),s=w(t),r=a.split("."),i=s.split("."),n=r.length,l=i.length;if(0===n||0===l||n<l)return!1;for(let e=0;e<n;e++)if(0===r[e].length)return!1;for(let e=0;e<l;e++)if(0===i[e].length){if(0===e){if(1===l)return!1;continue}return!1}for(let e=0;e<l;e++)if(0!==i[l-1-e].length&&0!==r[n-1-e].localeCompare(i[l-1-e]))return!1;return!0}function s(e,t){let s=w(e),r=w(t),i=s.split("@"),n=r.split("@");if(0===i.length||0===n.length||i.length<n.length)return!1;if(1===n.length){let e=a(i[1],n[0]);if(e){let e=i[1].split("."),t=n[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===s.localeCompare(r)}function r(e,t){let s=w(e),r=w(t),i=s.split("/"),n=r.split("/");if(n.length>1)return!1;if(i.length>1){for(let e=0;e<i.length;e++)if(i[e].length>0&&":"!==i[e].charAt(i[e].length-1)){let t=i[e].split(":");s=t[0];break}}let l=a(s,r);if(l){let e=s.split("."),t=r.split(".");return 0===t[0].length||e.length===t.length}return!1}function i(e,t){let a=e.valueBlock.valueHexView,s=t.valueBlock.valueHexView;if(4===a.length&&8===s.length){for(let e=0;e<4;e++)if((a[e]^s[e])&s[e+4])return!1;return!0}if(16===a.length&&32===s.length){for(let e=0;e<16;e++)if((a[e]^s[e])&s[e+16])return!1;return!0}return!1}function n(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let a=!0,s=0;for(let r=0;r<t.typesAndValues.length;r++){let i=!1;for(let n=s;n<e.typesAndValues.length;n++)if(i=e.typesAndValues[n].isEqual(t.typesAndValues[r]),e.typesAndValues[n].type===t.typesAndValues[r].type&&(a=a&&i),!0===i){if(0!==s&&s!==n)return!1;s=n+1;break}if(!1===i)return!1}return 0!==s&&a}try{if(0===this.certs.length)throw Error("Empty certificate array");let l=e.passedWhenNotRevValues||!1,u=e.initialPolicySet||[em],o=e.initialExplicitPolicy||!1,c=e.initialPolicyMappingInhibit||!1,h=e.initialInhibitPolicy||!1,m=e.initialPermittedSubtreesSet||[],d=e.initialExcludedSubtreesSet||[],f=e.initialRequiredNameForms||[],g=o,p=c,S=h,y=[!1,!1,!1],w=0,v=0,b=0,A=m,k=d,C=1;this.certs=await this.sort(l,t);let N=[];N.push(em);let V=[],I=Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)I[e]=!0;V.push(I);let B=Array(this.certs.length-1),E=Array(this.certs.length-1),H=g?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,C++){let t=this.certs[e];if(t.extensions){for(let a=0;a<t.extensions.length;a++){let s=t.extensions[a];if(s.extnID===eh){E[e]=s.parsedValue;for(let t=0;t<N.length;t++)if(N[t]===em){delete V[t][e];break}for(let t=0;t<s.parsedValue.certificatePolicies.length;t++){let a=-1,r=s.parsedValue.certificatePolicies[t].policyIdentifier;for(let e=0;e<N.length;e++)if(r===N[e]){a=e;break}if(-1===a){N.push(r);let t=Array(this.certs.length-1);t[e]=!0,V.push(t)}else V[a][e]=!0}}if(s.extnID===ed){if(p)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};B[e]=s.parsedValue}s.extnID===eg&&!1===g&&(0===s.parsedValue.requireExplicitPolicy?(g=!0,H=e):!1===y[0]?(y[0]=!0,w=s.parsedValue.requireExplicitPolicy):w=w>s.parsedValue.requireExplicitPolicy?s.parsedValue.requireExplicitPolicy:w,0===s.parsedValue.inhibitPolicyMapping?p=!0:!1===y[1]?(y[1]=!0,v=s.parsedValue.inhibitPolicyMapping+1):v=v>s.parsedValue.inhibitPolicyMapping+1?s.parsedValue.inhibitPolicyMapping+1:v),"2.5.29.54"===s.extnID&&!1===S&&(0===s.parsedValue.valueBlock.valueDec?S=!0:!1===y[2]?(y[2]=!0,b=s.parsedValue.valueBlock.valueDec):b=b>s.parsedValue.valueBlock.valueDec?s.parsedValue.valueBlock.valueDec:b)}if(!0===S){let t=-1;for(let e=0;e<N.length;e++)if(N[e]===em){t=e;break}-1!==t&&delete V[0][e]}!1===g&&!0===y[0]&&(w--,0===w&&(g=!0,H=e,y[0]=!1)),!1===p&&!0===y[1]&&(v--,0===v&&(p=!0,y[1]=!1)),!1===S&&!0===y[2]&&(b--,0===b&&(S=!0,y[2]=!1))}}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==B[e+1])for(let t=0;t<B[e+1].mappings.length;t++){if(B[e+1].mappings[t].issuerDomainPolicy===em||B[e+1].mappings[t].subjectDomainPolicy===em)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let a=-1,s=-1;for(let r=0;r<N.length;r++)N[r]===B[e+1].mappings[t].issuerDomainPolicy&&(a=r),N[r]===B[e+1].mappings[t].subjectDomainPolicy&&(s=r);void 0!==V[a][e]&&delete V[a][e];for(let r=0;r<E[e].certificatePolicies.length;r++)if(B[e+1].mappings[t].subjectDomainPolicy===E[e].certificatePolicies[r].policyIdentifier&&-1!==a&&-1!==s)for(let t=0;t<=e;t++)void 0!==V[s][t]&&(V[a][t]=!0,delete V[s][t])}for(let e=0;e<N.length;e++)if(N[e]===em)for(let t=0;t<H;t++)delete V[e][t];let D=[];for(let e=0;e<V.length;e++){let t=!0;for(let a=0;a<this.certs.length-1;a++){let s=!1;if(a<H&&N[e]===em&&N.length>1){t=!1;break}if(void 0===V[e][a]){if(a>=H){for(let e=0;e<N.length;e++)if(N[e]===em){!0===V[e][a]&&(s=!0);break}}if(!s){t=!1;break}}}!0===t&&D.push(N[e])}let O=[];if(1===u.length&&u[0]===em&&!1===g)O=u;else if(1===D.length&&D[0]===em)O=u;else for(let e=0;e<D.length;e++)for(let t=0;t<u.length;t++)if(u[t]===D[e]||u[t]===em){O.push(D[e]);break}let x={result:O.length>0,resultCode:0,resultMessage:O.length>0?"":'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:D,userConstrPolicies:O,explicitPolicyIndicator:g,policyMappings:B,certificatePath:this.certs};if(0===O.length||!1===x.result)return x;C=1;for(let e=this.certs.length-2;e>=0;e--,C++){let t=this.certs[e],l=[],u=[],o=[];if(t.extensions)for(let e=0;e<t.extensions.length;e++){let a=t.extensions[e];a.extnID===eu&&("permittedSubtrees"in a.parsedValue&&(u=u.concat(a.parsedValue.permittedSubtrees)),"excludedSubtrees"in a.parsedValue&&(o=o.concat(a.parsedValue.excludedSubtrees))),a.extnID===es&&(l=l.concat(a.parsedValue.altNames))}let c=f.length<=0;for(let e=0;e<f.length;e++)if(4===f[e].base.type){if(f[e].base.value.typesAndValues.length!==t.subject.typesAndValues.length)continue;c=!0;for(let a=0;a<t.subject.typesAndValues.length;a++)if(t.subject.typesAndValues[a].type!==f[e].base.value.typesAndValues[a].type){c=!1;break}}if(!1===c)throw x.result=!1,x.resultCode=21,x.resultMessage="No necessary name form found",x;let h=[[],[],[],[],[]];for(let e=0;e<A.length;e++)switch(A[e].base.type){case 1:h[0].push(A[e]);break;case 2:h[1].push(A[e]);break;case 4:h[2].push(A[e]);break;case 6:h[3].push(A[e]);break;case 7:h[4].push(A[e])}for(let e=0;e<5;e++){let u=!1,o=!1,c=h[e];for(let h=0;h<c.length;h++){switch(e){case 0:if(l.length>0)for(let e=0;e<l.length;e++)1===l[e].type&&(o=!0,u=u||s(l[e].value,c[h].base.value));else for(let e=0;e<t.subject.typesAndValues.length;e++)("1.2.840.113549.1.9.1"===t.subject.typesAndValues[e].type||"0.9.2342.19200300.100.1.3"===t.subject.typesAndValues[e].type)&&(o=!0,u=u||s(t.subject.typesAndValues[e].value.valueBlock.value,c[h].base.value));break;case 1:if(l.length>0)for(let e=0;e<l.length;e++)2===l[e].type&&(o=!0,u=u||a(l[e].value,c[h].base.value));break;case 2:o=!0,u=n(t.subject,c[h].base.value);break;case 3:if(l.length>0)for(let e=0;e<l.length;e++)6===l[e].type&&(o=!0,u=u||r(l[e].value,c[h].base.value));break;case 4:if(l.length>0)for(let e=0;e<l.length;e++)7===l[e].type&&(o=!0,u=u||i(l[e].value,c[h].base.value))}if(u)break}if(!1===u&&c.length>0&&o)throw x.result=!1,x.resultCode=41,x.resultMessage='Failed to meet "permitted sub-trees" name constraint',x}let m=!1;for(let e=0;e<k.length;e++){switch(k[e].base.type){case 1:if(l.length>=0)for(let t=0;t<l.length;t++)1===l[t].type&&(m=m||s(l[t].value,k[e].base.value));else for(let a=0;a<t.subject.typesAndValues.length;a++)("1.2.840.113549.1.9.1"===t.subject.typesAndValues[a].type||"0.9.2342.19200300.100.1.3"===t.subject.typesAndValues[a].type)&&(m=m||s(t.subject.typesAndValues[a].value.valueBlock.value,k[e].base.value));break;case 2:if(l.length>0)for(let t=0;t<l.length;t++)2===l[t].type&&(m=m||a(l[t].value,k[e].base.value));break;case 4:m=m||n(t.subject,k[e].base.value);break;case 6:if(l.length>0)for(let t=0;t<l.length;t++)6===l[t].type&&(m=m||r(l[t].value,k[e].base.value));break;case 7:if(l.length>0)for(let t=0;t<l.length;t++)7===l[t].type&&(m=m||i(l[t].value,k[e].base.value))}if(m)break}if(!0===m)throw x.result=!1,x.resultCode=42,x.resultMessage='Failed to meet "excluded sub-trees" name constraint',x;A=A.concat(u),k=k.concat(o)}return x}catch(e){if(e instanceof Error){if(e instanceof l6)return{result:!1,resultCode:e.code,resultMessage:e.message,error:e};return{result:!1,resultCode:l.unknown,resultMessage:e.message,error:e}}if(e&&"object"==typeof e&&"resultMessage"in e)return e;return{result:!1,resultCode:-1,resultMessage:`${e}`}}}}let l7="tbsResponseData",ue="signatureAlgorithm",ut="signature",ua="certs",us="BasicOCSPResponse",ur=`${us}.${l7}`,ui=`${us}.${ue}`,un=`${us}.${ut}`,ul=`${us}.${ua}`,uu=[ur,ui,un,ul];class uo extends y{constructor(e={}){super(),this.tbsResponseData=h.H$(e,l7,uo.defaultValues(l7)),this.signatureAlgorithm=h.H$(e,ue,uo.defaultValues(ue)),this.signature=h.H$(e,ut,uo.defaultValues(ut)),ua in e&&(this.certs=h.H$(e,ua,uo.defaultValues(ua))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case l7:return new lY;case ue:return new T;case ut:return new o.BitString;case ua:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"type":{let e=lY.compareWithDefault("tbs",t.tbs)&&lY.compareWithDefault("responderID",t.responderID)&&lY.compareWithDefault("producedAt",t.producedAt)&&lY.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&lY.compareWithDefault("responseExtensions",t.responseExtensions)),e}case ue:return""===t.algorithmId&&"algorithmParams"in t==!1;case ut:return t.isEqual(uo.defaultValues(e));case ua:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||us,value:[lY.schema(t.tbsResponseData||{names:{blockName:ur}}),T.schema(t.signatureAlgorithm||{names:{blockName:ui}}),new o.BitString({name:t.signature||un}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:[new o.Repeated({name:ul,value:rj.schema(t.certs||{})})]})]})]})}fromSchema(e){h.ze(e,uu);let t=o.compareSchema(e,e,uo.schema());S.assertSchema(t,this.className),this.tbsResponseData=new lY({schema:t.result[ur]}),this.signatureAlgorithm=new T({schema:t.result[ui]}),this.signature=t.result[un],ul in t.result&&(this.certs=Array.from(t.result[ul],e=>new rj({schema:e})))}toSchema(){let e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new o.Sequence({value:e})}toJSON(){let e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}async getCertificateStatus(e,t,a=aM(!0)){let s={isForCertificate:!1,status:2},r={},i=[];for(let s of this.tbsResponseData.responses){let n=a.getAlgorithmByOID(s.certID.hashAlgorithm.algorithmId,!0,"CertID.hashAlgorithm");if(!r[n.name]){r[n.name]=1;let s=new lx;i.push(s),await s.createForCertificate(e,{hashAlgorithm:n.name,issuerCertificate:t},a)}}for(let e of this.tbsResponseData.responses)for(let t of i)if(e.certID.isEqual(t)){s.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(s.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:s.status=0;break;case 2:s.status=2}}}catch(e){}return s}return s}async sign(e,t="SHA-1",a=aM(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),r=s.parameters.algorithm;if(!("name"in r))throw Error("Empty algorithm");this.signatureAlgorithm=s.signatureAlgorithm,this.tbsResponseData.tbsView=new Uint8Array(this.tbsResponseData.toSchema(!0).toBER());let i=await a.signWithPrivateKey(this.tbsResponseData.tbsView,e,{algorithm:r});this.signature=new o.BitString({valueHex:i})}async verify(e={},t=aM(!0)){let a=null,s=-1,r=e.trustedCerts||[];if(!this.certs)throw Error("No certificates attached to the BasicOCSPResponse");switch(!0){case this.tbsResponseData.responderID instanceof N:for(let[e,t]of this.certs.entries())if(t.subject.isEqual(this.tbsResponseData.responderID)){s=e;break}break;case this.tbsResponseData.responderID instanceof o.OctetString:for(let[e,a]of this.certs.entries()){let r=await t.digest({name:"sha-1"},a.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(h.dN(r,this.tbsResponseData.responderID.valueBlock.valueHex)){s=e;break}}break;default:throw Error("Wrong value for responderID")}if(-1===s)throw Error("Correct certificate was not found in OCSP response");a=this.certs[s];let i=[a];for(let e of this.certs){let t=await rU(e,a);t&&i.push(t)}let n=new l9({certs:i,trustedCerts:r}),l=await n.verify({},t);if(!l.result)throw Error("Validation of signer's certificate failed");return t.verifyWithPublicKey(this.tbsResponseData.tbsView,this.signature,this.certs[s].subjectPublicKeyInfo,this.signatureAlgorithm)}}uo.CLASS_NAME="BasicOCSPResponse";let uc="version",uh="subject",um="subjectPublicKeyInfo",ud="attributes",uf="signatureAlgorithm",ug="signatureValue",up="CertificationRequestInfo",uS=`${up}.version`,uy=`${up}.subject`,uw=`${up}.subjectPublicKeyInfo`,uv=`${up}.attributes`,ub=[up,uS,uy,uw,uv,uf,ug];class uA extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",uA.defaultValues("tbs"))),this.version=h.H$(e,uc,uA.defaultValues(uc)),this.subject=h.H$(e,uh,uA.defaultValues(uh)),this.subjectPublicKeyInfo=h.H$(e,um,uA.defaultValues(um)),ud in e&&(this.attributes=h.H$(e,ud,uA.defaultValues(ud))),this.signatureAlgorithm=h.H$(e,uf,uA.defaultValues(uf)),this.signatureValue=h.H$(e,ug,uA.defaultValues(ug)),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return f;case uc:return 0;case uh:return new N;case um:return new tZ;case ud:return[];case uf:return new T;case ug:return new o.BitString;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({value:[function(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.CertificationRequestInfo||up,value:[new o.Integer({name:t.CertificationRequestInfoVersion||uS}),N.schema(t.subject||{names:{blockName:uy}}),tZ.schema({names:{blockName:uw}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({optional:!0,name:t.CertificationRequestInfoAttributes||uv,value:G.schema(t.attributes||{})})]})]})}(t.certificationRequestInfo||{}),new o.Sequence({name:t.signatureAlgorithm||uf,value:[new o.ObjectIdentifier,new o.Any({optional:!0})]}),new o.BitString({name:t.signatureValue||ug})]})}fromSchema(e){h.ze(e,ub);let t=o.compareSchema(e,e,uA.schema());S.assertSchema(t,this.className),this.tbsView=t.result.CertificationRequestInfo.valueBeforeDecodeView,this.version=t.result[uS].valueBlock.valueDec,this.subject=new N({schema:t.result[uy]}),this.subjectPublicKeyInfo=new tZ({schema:t.result[uw]}),uv in t.result&&(this.attributes=Array.from(t.result[uv],e=>new G({schema:e}))),this.signatureAlgorithm=new T({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){let e=[new o.Integer({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return ud in this&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes||[],e=>e.toSchema())})),new o.Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return uA.schema();let e=o.fromBER(this.tbsView);S.assert(e,"PKCS#10 Certificate Request"),t=e.result}else t=this.encodeTBS();return new o.Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){let e={tbs:c.ep.ToHex(this.tbsView),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return ud in this&&(e.attributes=Array.from(this.attributes||[],e=>e.toJSON())),e}async sign(e,t="SHA-1",a=aM(!0)){if(!e)throw Error("Need to provide a private key for signing");let s=await a.getSignatureParameters(e,t),r=s.parameters;this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());let i=await a.signWithPrivateKey(this.tbsView,e,r);this.signatureValue=new o.BitString({valueHex:i})}async verify(e=aM(!0)){return e.verifyWithPublicKey(this.tbsView,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}async getPublicKey(e,t=aM(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}uA.CLASS_NAME="CertificationRequest";let uk="digestAlgorithm",uC="digest",uN=[uk,uC];class uV extends y{constructor(e={}){super(),this.digestAlgorithm=h.H$(e,uk,uV.defaultValues(uk)),this.digest=h.H$(e,uC,uV.defaultValues(uC)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uk:return new T;case uC:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uk:return T.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case uC:return t.isEqual(uV.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.digestAlgorithm||{names:{blockName:uk}}),new o.OctetString({name:t.digest||uC})]})}fromSchema(e){h.ze(e,uN);let t=o.compareSchema(e,e,uV.schema({names:{digestAlgorithm:{names:{blockName:uk}},digest:uC}}));S.assertSchema(t,this.className),this.digestAlgorithm=new T({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new o.Sequence({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}uV.CLASS_NAME="DigestInfo";let uI="eContentType",uB="eContent",uE=[uI,uB];class uH extends y{constructor(e={}){if(super(),this.eContentType=h.H$(e,uI,uH.defaultValues(uI)),uB in e&&(this.eContent=h.H$(e,uB,uH.defaultValues(uB)),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){let e=new o.OctetString({idBlock:{isConstructed:!0},isConstructed:!0}),t=0,a=this.eContent.valueBlock.valueHexView.slice().buffer,s=a.byteLength;for(;s>0;){let r=new Uint8Array(a,t,t+65536>a.byteLength?a.byteLength-t:65536),i=new ArrayBuffer(r.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=r[e];e.valueBlock.value.push(new o.OctetString({valueHex:i})),s-=r.length,t+=r.length}this.eContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uI:return"";case uB:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uI:return""===t;case uB:if(1===t.idBlock.tagClass&&4===t.idBlock.tagNumber)return t.isEqual(uH.defaultValues(uB));return!1;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.eContentType||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Any({name:t.eContent||""})]})]})}fromSchema(e){h.ze(e,uE);let t=o.compareSchema(e,e,uH.schema({names:{eContentType:uI,eContent:uB}}));S.assertSchema(t,this.className),this.eContentType=t.result.eContentType.valueBlock.toString(),uB in t.result&&(this.eContent=t.result.eContent)}toSchema(){let e=[];return e.push(new o.ObjectIdentifier({value:this.eContentType})),this.eContent&&!1===uH.compareWithDefault(uB,this.eContent)&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new o.Sequence({value:e})}toJSON(){let e={eContentType:this.eContentType};return this.eContent&&!1===uH.compareWithDefault(uB,this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}uH.CLASS_NAME="EncapsulatedContentInfo";let uD="macSalt",uO="iterations",ux=["mac",uD,uO];class u$ extends y{constructor(e={}){super(),this.mac=h.H$(e,"mac",u$.defaultValues("mac")),this.macSalt=h.H$(e,uD,u$.defaultValues(uD)),uO in e&&(this.iterations=h.H$(e,uO,u$.defaultValues(uO))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mac":return new uV;case uD:return new o.OctetString;case uO:return 1;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"mac":return uV.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&uV.compareWithDefault("digest",t.digest);case uD:return t.isEqual(u$.defaultValues(e));case uO:return t===u$.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",optional:t.optional||!0,value:[uV.schema(t.mac||{names:{blockName:"mac"}}),new o.OctetString({name:t.macSalt||uD}),new o.Integer({optional:!0,name:t.iterations||uO})]})}fromSchema(e){h.ze(e,ux);let t=o.compareSchema(e,e,u$.schema({names:{mac:{names:{blockName:"mac"}},macSalt:uD,iterations:uO}}));S.assertSchema(t,this.className),this.mac=new uV({schema:t.result.mac}),this.macSalt=t.result.macSalt,uO in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){let e=[this.mac.toSchema(),this.macSalt];return void 0!==this.iterations&&e.push(new o.Integer({value:this.iterations})),new o.Sequence({value:e})}toJSON(){let e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return void 0!==this.iterations&&(e.iterations=this.iterations),e}}u$.CLASS_NAME="MacData";let uP="hashAlgorithm",uq="hashedMessage",uK=[uP,uq];class uR extends y{constructor(e={}){super(),this.hashAlgorithm=h.H$(e,uP,uR.defaultValues(uP)),this.hashedMessage=h.H$(e,uq,uR.defaultValues(uq)),e.schema&&this.fromSchema(e.schema)}static async create(e,t,a=aM(!0)){let s=a.getOIDByAlgorithm({name:e},!0,"hashAlgorithm"),r=await a.digest(e,t),i=new uR({hashAlgorithm:new T({algorithmId:s,algorithmParams:new o.Null}),hashedMessage:new o.OctetString({valueHex:r})});return i}static defaultValues(e){switch(e){case uP:return new T;case uq:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uP:return""===t.algorithmId&&"algorithmParams"in t==!1;case uq:return 0===t.isEqual(uR.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.hashAlgorithm||{}),new o.OctetString({name:t.hashedMessage||""})]})}fromSchema(e){h.ze(e,uK);let t=o.compareSchema(e,e,uR.schema({names:{hashAlgorithm:{names:{blockName:uP}},hashedMessage:uq}}));S.assertSchema(t,this.className),this.hashAlgorithm=new T({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new o.Sequence({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}uR.CLASS_NAME="MessageImprint";let uJ="reqCert",uj="singleRequestExtensions",uU=[uJ,uj];class Request extends y{constructor(e={}){super(),this.reqCert=h.H$(e,uJ,Request.defaultValues(uJ)),uj in e&&(this.singleRequestExtensions=h.H$(e,uj,Request.defaultValues(uj))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uJ:return new lx;case uj:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uJ:return t.isEqual(Request.defaultValues(e));case uj:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[lx.schema(t.reqCert||{}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[sc.schema(t.extensions||{names:{blockName:t.singleRequestExtensions||""}})]})]})}fromSchema(e){h.ze(e,uU);let t=o.compareSchema(e,e,Request.schema({names:{reqCert:{names:{blockName:uJ}},extensions:{names:{blockName:uj}}}}));S.assertSchema(t,this.className),this.reqCert=new lx({schema:t.result.reqCert}),uj in t.result&&(this.singleRequestExtensions=Array.from(t.result.singleRequestExtensions.valueBlock.value,e=>new sc({schema:e})))}toSchema(){let e=[];return e.push(this.reqCert.toSchema()),this.singleRequestExtensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:Array.from(this.singleRequestExtensions,e=>e.toSchema())})]})),new o.Sequence({value:e})}toJSON(){let e={reqCert:this.reqCert.toJSON()};return this.singleRequestExtensions&&(e.singleRequestExtensions=Array.from(this.singleRequestExtensions,e=>e.toJSON())),e}}Request.CLASS_NAME="Request";let uT="version",uL="requestorName",uM="requestList",u_="requestExtensions",uW="TBSRequest",uz=`${uW}.${uT}`,uF=`${uW}.${uL}`,uG=`${uW}.requests`,uQ=`${uW}.${u_}`,uZ=[uW,uz,uF,uG,uQ];class uX extends y{constructor(e={}){super(),this.tbsView=new Uint8Array(h.H$(e,"tbs",uX.defaultValues("tbs"))),uT in e&&(this.version=h.H$(e,uT,uX.defaultValues(uT))),uL in e&&(this.requestorName=h.H$(e,uL,uX.defaultValues(uL))),this.requestList=h.H$(e,uM,uX.defaultValues(uM)),u_ in e&&(this.requestExtensions=h.H$(e,u_,uX.defaultValues(u_))),e.schema&&this.fromSchema(e.schema)}get tbs(){return c.vJ.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}static defaultValues(e){switch(e){case"tbs":return f;case uT:return 0;case uL:return new B;case uM:case u_:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"tbs":return 0===t.byteLength;case uT:return t===uX.defaultValues(e);case uL:return t.type===B.defaultValues("type")&&0===Object.keys(t.value).length;case uM:case u_:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||uW,value:[new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({name:t.TBSRequestVersion||uz})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[B.schema(t.requestorName||{names:{blockName:uF}})]}),new o.Sequence({name:t.requestList||"TBSRequest.requestList",value:[new o.Repeated({name:t.requests||uG,value:Request.schema(t.requestNames||{})})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[sd.schema(t.extensions||{names:{blockName:t.requestExtensions||uQ}})]})]})}fromSchema(e){h.ze(e,uZ);let t=o.compareSchema(e,e,uX.schema());S.assertSchema(t,this.className),this.tbsView=t.result.TBSRequest.valueBeforeDecodeView,uz in t.result&&(this.version=t.result[uz].valueBlock.valueDec),uF in t.result&&(this.requestorName=new B({schema:t.result[uF]})),this.requestList=Array.from(t.result[uG],e=>new Request({schema:e})),uQ in t.result&&(this.requestExtensions=Array.from(t.result[uQ].valueBlock.value,e=>new sc({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return uX.schema();let e=o.fromBER(this.tbsView);if(S.assert(e,"TBS Request"),!(e.result instanceof o.Sequence))throw Error("ASN.1 result should be SEQUENCE");t=e.result}else{let e=[];void 0!==this.version&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new o.Integer({value:this.version})]})),this.requestorName&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.requestorName.toSchema()]})),e.push(new o.Sequence({value:Array.from(this.requestList,e=>e.toSchema())})),this.requestExtensions&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new o.Sequence({value:Array.from(this.requestExtensions,e=>e.toSchema())})]})),t=new o.Sequence({value:e})}return t}toJSON(){let e={};return void 0!=this.version&&(e.version=this.version),this.requestorName&&(e.requestorName=this.requestorName.toJSON()),e.requestList=Array.from(this.requestList,e=>e.toJSON()),this.requestExtensions&&(e.requestExtensions=Array.from(this.requestExtensions,e=>e.toJSON())),e}}uX.CLASS_NAME="TBSRequest";let uY="signatureAlgorithm",u1="signature",u0="certs";class u2 extends y{constructor(e={}){super(),this.signatureAlgorithm=h.H$(e,uY,u2.defaultValues(uY)),this.signature=h.H$(e,u1,u2.defaultValues(u1)),u0 in e&&(this.certs=h.H$(e,u0,u2.defaultValues(u0))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uY:return new T;case u1:return new o.BitString;case u0:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uY:return""===t.algorithmId&&"algorithmParams"in t==!1;case u1:return t.isEqual(u2.defaultValues(e));case u0:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[T.schema(t.signatureAlgorithm||{}),new o.BitString({name:t.signature||""}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:[new o.Repeated({name:t.certs||"",value:rj.schema({})})]})]})]})}fromSchema(e){h.ze(e,[uY,u1,u0]);let t=o.compareSchema(e,e,u2.schema({names:{signatureAlgorithm:{names:{blockName:uY}},signature:u1,certs:u0}}));S.assertSchema(t,this.className),this.signatureAlgorithm=new T({schema:t.result.signatureAlgorithm}),this.signature=t.result.signature,u0 in t.result&&(this.certs=Array.from(t.result.certs,e=>new rj({schema:e})))}toSchema(){let e=[];return e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new o.Sequence({value:e})}toJSON(){let e={signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}}u2.CLASS_NAME="Signature";let u3="tbsRequest",u4="optionalSignature",u8=[u3,u4];class u5 extends y{constructor(e={}){super(),this.tbsRequest=h.H$(e,u3,u5.defaultValues(u3)),u4 in e&&(this.optionalSignature=h.H$(e,u4,u5.defaultValues(u4))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case u3:return new uX;case u4:return new u2;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case u3:return uX.compareWithDefault("tbs",t.tbs)&&uX.compareWithDefault("version",t.version)&&uX.compareWithDefault("requestorName",t.requestorName)&&uX.compareWithDefault("requestList",t.requestList)&&uX.compareWithDefault("requestExtensions",t.requestExtensions);case u4:return u2.compareWithDefault("signatureAlgorithm",t.signatureAlgorithm)&&u2.compareWithDefault("signature",t.signature)&&u2.compareWithDefault("certs",t.certs);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"OCSPRequest",value:[uX.schema(t.tbsRequest||{names:{blockName:u3}}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[u2.schema(t.optionalSignature||{names:{blockName:u4}})]})]})}fromSchema(e){h.ze(e,u8);let t=o.compareSchema(e,e,u5.schema());S.assertSchema(t,this.className),this.tbsRequest=new uX({schema:t.result.tbsRequest}),u4 in t.result&&(this.optionalSignature=new u2({schema:t.result.optionalSignature}))}toSchema(e=!1){let t=[];return t.push(this.tbsRequest.toSchema(e)),this.optionalSignature&&t.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.optionalSignature.toSchema()]})),new o.Sequence({value:t})}toJSON(){let e={tbsRequest:this.tbsRequest.toJSON()};return this.optionalSignature&&(e.optionalSignature=this.optionalSignature.toJSON()),e}async createForCertificate(e,t,a=aM(!0)){let s=new lx;await s.createForCertificate(e,t,a),this.tbsRequest.requestList.push(new Request({reqCert:s}))}async sign(e,t="SHA-1",a=aM(!0)){if(p.assertEmpty(e,"privateKey","OCSPRequest.sign method"),!this.optionalSignature)throw Error('Need to create "optionalSignature" field before signing');let s=await a.getSignatureParameters(e,t),r=s.parameters;this.optionalSignature.signatureAlgorithm=s.signatureAlgorithm;let i=this.tbsRequest.toSchema(!0).toBER(!1),n=await a.signWithPrivateKey(i,e,r);this.optionalSignature.signature=new o.BitString({valueHex:n})}verify(){}}u5.CLASS_NAME="OCSPRequest";let u6="responseType",u9="response",u7=[u6,u9];class oe extends y{constructor(e={}){super(),this.responseType=h.H$(e,u6,oe.defaultValues(u6)),this.response=h.H$(e,u9,oe.defaultValues(u9)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case u6:return"";case u9:return new o.OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case u6:return""===t;case u9:return t.isEqual(oe.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.ObjectIdentifier({name:t.responseType||""}),new o.OctetString({name:t.response||""})]})}fromSchema(e){h.ze(e,u7);let t=o.compareSchema(e,e,oe.schema({names:{responseType:u6,response:u9}}));S.assertSchema(t,this.className),this.responseType=t.result.responseType.valueBlock.toString(),this.response=t.result.response}toSchema(){return new o.Sequence({value:[new o.ObjectIdentifier({value:this.responseType}),this.response]})}toJSON(){return{responseType:this.responseType,response:this.response.toJSON()}}}oe.CLASS_NAME="ResponseBytes";let ot="responseStatus",oa="responseBytes";class os extends y{constructor(e={}){super(),this.responseStatus=h.H$(e,ot,os.defaultValues(ot)),oa in e&&(this.responseBytes=h.H$(e,oa,os.defaultValues(oa))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ot:return new o.Enumerated;case oa:return new oe;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ot:return t.isEqual(os.defaultValues(e));case oa:return oe.compareWithDefault("responseType",t.responseType)&&oe.compareWithDefault("response",t.response);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"OCSPResponse",value:[new o.Enumerated({name:t.responseStatus||ot}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[oe.schema(t.responseBytes||{names:{blockName:oa}})]})]})}fromSchema(e){h.ze(e,[ot,oa]);let t=o.compareSchema(e,e,os.schema());S.assertSchema(t,this.className),this.responseStatus=t.result.responseStatus,oa in t.result&&(this.responseBytes=new oe({schema:t.result.responseBytes}))}toSchema(){let e=[];return e.push(this.responseStatus),this.responseBytes&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.responseBytes.toSchema()]})),new o.Sequence({value:e})}toJSON(){let e={responseStatus:this.responseStatus.toJSON()};return this.responseBytes&&(e.responseBytes=this.responseBytes.toJSON()),e}async getCertificateStatus(e,t,a=aM(!0)){let s;let r={isForCertificate:!1,status:2};if(!this.responseBytes||this.responseBytes.responseType!==eC)return r;try{let e=o.fromBER(this.responseBytes.response.valueBlock.valueHexView);S.assert(e,"Basic OCSP response"),s=new uo({schema:e.result})}catch(e){return r}return s.getCertificateStatus(e,t,a)}async sign(e,t,a=aM(!0)){var s;if(this.responseBytes&&this.responseBytes.responseType===eC){let s=uo.fromBER(this.responseBytes.response.valueBlock.valueHexView);return s.sign(e,t,a)}throw Error(`Unknown ResponseBytes type: ${(null===(s=this.responseBytes)||void 0===s?void 0:s.responseType)||"Unknown"}`)}async verify(e=null,t=aM(!0)){var a;if(oa in this==!1)throw Error("Empty ResponseBytes field");if(this.responseBytes&&this.responseBytes.responseType===eC){let a=uo.fromBER(this.responseBytes.response.valueBlock.valueHexView);return null!==e&&(a.certs||(a.certs=[]),a.certs.push(e)),a.verify({},t)}throw Error(`Unknown ResponseBytes type: ${(null===(a=this.responseBytes)||void 0===a?void 0:a.responseType)||"Unknown"}`)}}os.CLASS_NAME="OCSPResponse";let or="type",oi="attributes",on="encodedValue",ol=[oi];class ou extends y{constructor(e={}){super(),this.type=h.H$(e,or,ou.defaultValues(or)),this.attributes=h.H$(e,oi,ou.defaultValues(oi)),this.encodedValue=h.H$(e,on,ou.defaultValues(on)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case or:return -1;case oi:return[];case on:return f;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case or:return t===ou.defaultValues(or);case oi:return 0===t.length;case on:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Constructed({name:t.blockName||"",optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber||0},value:[new o.Repeated({name:t.attributes||"",value:G.schema()})]})}fromSchema(e){h.ze(e,ol);let t=o.compareSchema(e,e,ou.schema({names:{tagNumber:this.type,attributes:oi}}));S.assertSchema(t,this.className),this.type=t.result.idBlock.tagNumber,this.encodedValue=c.vJ.toArrayBuffer(t.result.valueBeforeDecodeView);let a=new Uint8Array(this.encodedValue);if(a[0]=49,oi in t.result==!1){if(0!==this.type)return;throw Error("Wrong structure of SignedUnsignedAttributes")}this.attributes=Array.from(t.result.attributes,e=>new G({schema:e}))}toSchema(){if(ou.compareWithDefault(or,this.type)||ou.compareWithDefault(oi,this.attributes))throw Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(ou.compareWithDefault(or,this.type)||ou.compareWithDefault(oi,this.attributes))throw Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}}ou.CLASS_NAME="SignedAndUnsignedAttributes";let oo="version",oc="digestAlgorithm",oh="signedAttrs",om="signatureAlgorithm",od="signature",of="unsignedAttrs",og="SignerInfo",op=`${og}.${oo}`,oS=`${og}.sid`,oy=`${og}.${oc}`,ow=`${og}.${oh}`,ov=`${og}.${om}`,ob=`${og}.${od}`,oA=`${og}.${of}`,ok=[op,oS,oy,ow,ov,ob,oA];class oC extends y{constructor(e={}){super(),this.version=h.H$(e,oo,oC.defaultValues(oo)),this.sid=h.H$(e,"sid",oC.defaultValues("sid")),this.digestAlgorithm=h.H$(e,oc,oC.defaultValues(oc)),oh in e&&(this.signedAttrs=h.H$(e,oh,oC.defaultValues(oh))),this.signatureAlgorithm=h.H$(e,om,oC.defaultValues(om)),this.signature=h.H$(e,od,oC.defaultValues(od)),of in e&&(this.unsignedAttrs=h.H$(e,of,oC.defaultValues(of))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oo:return 0;case"sid":return new o.Any;case oc:return new T;case oh:return new ou({type:0});case om:return new T;case od:return new o.OctetString;case of:return new ou({type:1});default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oo:return oC.defaultValues(oo)===t;case"sid":return t instanceof o.Any;case oc:if(t instanceof T==!1)return!1;return t.isEqual(oC.defaultValues(oc));case oh:return ou.compareWithDefault("type",t.type)&&ou.compareWithDefault("attributes",t.attributes)&&ou.compareWithDefault("encodedValue",t.encodedValue);case om:if(t instanceof T==!1)return!1;return t.isEqual(oC.defaultValues(om));case od:case of:return ou.compareWithDefault("type",t.type)&&ou.compareWithDefault("attributes",t.attributes)&&ou.compareWithDefault("encodedValue",t.encodedValue);default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:og,value:[new o.Integer({name:t.version||op}),new o.Choice({value:[i8.schema(t.sidSchema||{names:{blockName:oS}}),new o.Choice({value:[new o.Constructed({optional:!0,name:t.sid||oS,idBlock:{tagClass:3,tagNumber:0},value:[new o.OctetString]}),new o.Primitive({optional:!0,name:t.sid||oS,idBlock:{tagClass:3,tagNumber:0}})]})]}),T.schema(t.digestAlgorithm||{names:{blockName:oy}}),ou.schema(t.signedAttrs||{names:{blockName:ow,tagNumber:0}}),T.schema(t.signatureAlgorithm||{names:{blockName:ov}}),new o.OctetString({name:t.signature||ob}),ou.schema(t.unsignedAttrs||{names:{blockName:oA,tagNumber:1}})]})}fromSchema(e){h.ze(e,ok);let t=o.compareSchema(e,e,oC.schema());S.assertSchema(t,this.className),this.version=t.result[op].valueBlock.valueDec;let a=t.result[oS];1===a.idBlock.tagClass?this.sid=new i8({schema:a}):this.sid=a,this.digestAlgorithm=new T({schema:t.result[oy]}),ow in t.result&&(this.signedAttrs=new ou({type:0,schema:t.result[ow]})),this.signatureAlgorithm=new T({schema:t.result[ov]}),this.signature=t.result[ob],oA in t.result&&(this.unsignedAttrs=new ou({type:1,schema:t.result[oA]}))}toSchema(){if(oC.compareWithDefault("sid",this.sid))throw Error('Incorrectly initialized "SignerInfo" class');let e=[];return e.push(new o.Integer({value:this.version})),this.sid instanceof i8?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),this.signedAttrs&&!1===oC.compareWithDefault(oh,this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.unsignedAttrs&&!1===oC.compareWithDefault(of,this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new o.Sequence({value:e})}toJSON(){if(oC.compareWithDefault("sid",this.sid))throw Error('Incorrectly initialized "SignerInfo" class');let e={version:this.version,digestAlgorithm:this.digestAlgorithm.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.sid instanceof o.Any||(e.sid=this.sid.toJSON()),this.signedAttrs&&!1===oC.compareWithDefault(oh,this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),this.unsignedAttrs&&!1===oC.compareWithDefault(of,this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}oC.CLASS_NAME="SignerInfo";let oN="version",oV="policy",oI="messageImprint",oB="serialNumber",oE="genTime",oH="ordering",oD="nonce",oO="accuracy",ox="extensions",o$="TSTInfo",oP=`${o$}.${oN}`,oq=`${o$}.${oV}`,oK=`${o$}.${oI}`,oR=`${o$}.${oB}`,oJ=`${o$}.${oE}`,oj=`${o$}.${oO}`,oU=`${o$}.${oH}`,oT=`${o$}.${oD}`,oL=`${o$}.tsa`,oM=`${o$}.${ox}`,o_=[oP,oq,oK,oR,oJ,oj,oU,oT,oL,oM];class oW extends y{constructor(e={}){super(),this.version=h.H$(e,oN,oW.defaultValues(oN)),this.policy=h.H$(e,oV,oW.defaultValues(oV)),this.messageImprint=h.H$(e,oI,oW.defaultValues(oI)),this.serialNumber=h.H$(e,oB,oW.defaultValues(oB)),this.genTime=h.H$(e,oE,oW.defaultValues(oE)),oO in e&&(this.accuracy=h.H$(e,oO,oW.defaultValues(oO))),oH in e&&(this.ordering=h.H$(e,oH,oW.defaultValues(oH))),oD in e&&(this.nonce=h.H$(e,oD,oW.defaultValues(oD))),"tsa"in e&&(this.tsa=h.H$(e,"tsa",oW.defaultValues("tsa"))),ox in e&&(this.extensions=h.H$(e,ox,oW.defaultValues(ox))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oN:return 0;case oV:return"";case oI:return new uR;case oB:return new o.Integer;case oE:return new Date(0,0,0);case oO:return new q;case oH:return!1;case oD:return new o.Integer;case"tsa":return new B;case ox:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oN:case oV:case oE:case oH:return t===oW.defaultValues(oH);case oI:return uR.compareWithDefault(uP,t.hashAlgorithm)&&uR.compareWithDefault(uq,t.hashedMessage);case oB:case oD:return t.isEqual(oW.defaultValues(oD));case oO:return q.compareWithDefault(x,t.seconds)&&q.compareWithDefault($,t.millis)&&q.compareWithDefault(P,t.micros);case"tsa":return B.compareWithDefault(V,t.type)&&B.compareWithDefault(I,t.value);case ox:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||o$,value:[new o.Integer({name:t.version||oP}),new o.ObjectIdentifier({name:t.policy||oq}),uR.schema(t.messageImprint||{names:{blockName:oK}}),new o.Integer({name:t.serialNumber||oR}),new o.GeneralizedTime({name:t.genTime||oJ}),q.schema(t.accuracy||{names:{blockName:oj}}),new o.Boolean({name:t.ordering||oU,optional:!0}),new o.Integer({name:t.nonce||oT,optional:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[B.schema(t.tsa||{names:{blockName:oL}})]}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new o.Repeated({name:t.extensions||oM,value:sc.schema(t.extension||{})})]})]})}fromSchema(e){h.ze(e,o_);let t=o.compareSchema(e,e,oW.schema());S.assertSchema(t,this.className),this.version=t.result[oP].valueBlock.valueDec,this.policy=t.result[oq].valueBlock.toString(),this.messageImprint=new uR({schema:t.result[oK]}),this.serialNumber=t.result[oR],this.genTime=t.result[oJ].toDate(),oj in t.result&&(this.accuracy=new q({schema:t.result[oj]})),oU in t.result&&(this.ordering=t.result[oU].valueBlock.value),oT in t.result&&(this.nonce=t.result[oT]),oL in t.result&&(this.tsa=new B({schema:t.result[oL]})),oM in t.result&&(this.extensions=Array.from(t.result[oM],e=>new sc({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(new o.ObjectIdentifier({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new o.GeneralizedTime({valueDate:this.genTime})),this.accuracy&&e.push(this.accuracy.toSchema()),void 0!==this.ordering&&e.push(new o.Boolean({value:this.ordering})),this.nonce&&e.push(this.nonce),this.tsa&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),this.extensions&&e.push(new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return this.accuracy&&(e.accuracy=this.accuracy.toJSON()),void 0!==this.ordering&&(e.ordering=this.ordering),this.nonce&&(e.nonce=this.nonce.toJSON()),this.tsa&&(e.tsa=this.tsa.toJSON()),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async verify(e,t=aM(!0)){if(!e.data)throw Error('"data" is a mandatory attribute for TST_INFO verification');let a=e.data;if(e.notBefore&&this.genTime<e.notBefore)throw Error("Generation time for TSTInfo object is less than notBefore value");if(e.notAfter&&this.genTime>e.notAfter)throw Error("Generation time for TSTInfo object is more than notAfter value");let s=t.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId,!0,"MessageImprint.hashAlgorithm"),r=await t.digest(s.name,new Uint8Array(a));return c.vJ.isEqual(r,this.messageImprint.hashedMessage.valueBlock.valueHexView)}}oW.CLASS_NAME="TSTInfo";let oz="version",oF="digestAlgorithms",oG="encapContentInfo",oQ="certificates",oZ="crls",oX="signerInfos",oY="ocsps",o1="SignedData",o0=`${o1}.${oz}`,o2=`${o1}.${oF}`,o3=`${o1}.${oG}`,o4=`${o1}.${oQ}`,o8=`${o1}.${oZ}`,o5=`${o1}.${oX}`,o6=[o0,o2,o3,o4,o8,o5];class o9 extends Error{constructor({message:e,code:t=0,date:a=new Date,signatureVerified:s=null,signerCertificate:r=null,signerCertificateVerified:i=null,timestampSerial:n=null,certificatePath:l=[]}){super(e),this.name="SignedDataVerifyError",this.date=a,this.code=t,this.timestampSerial=n,this.signatureVerified=s,this.signerCertificate=r,this.signerCertificateVerified=i,this.certificatePath=l}}class o7 extends y{constructor(e={}){super(),this.version=h.H$(e,oz,o7.defaultValues(oz)),this.digestAlgorithms=h.H$(e,oF,o7.defaultValues(oF)),this.encapContentInfo=h.H$(e,oG,o7.defaultValues(oG)),oQ in e&&(this.certificates=h.H$(e,oQ,o7.defaultValues(oQ))),oZ in e&&(this.crls=h.H$(e,oZ,o7.defaultValues(oZ))),oY in e&&(this.ocsps=h.H$(e,oY,o7.defaultValues(oY))),this.signerInfos=h.H$(e,oX,o7.defaultValues(oX)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oz:return 0;case oF:return[];case oG:return new uH;case oQ:case oZ:case oY:case oX:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oz:return t===o7.defaultValues(oz);case oG:return uH.compareWithDefault("eContentType",t.eContentType)&&uH.compareWithDefault("eContent",t.eContent);case oF:case oQ:case oZ:case oY:case oX:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return void 0===t.optional&&(t.optional=!1),new o.Sequence({name:t.blockName||o1,optional:t.optional,value:[new o.Integer({name:t.version||o0}),new o.Set({value:[new o.Repeated({name:t.digestAlgorithms||o2,value:T.schema()})]}),uH.schema(t.encapContentInfo||{names:{blockName:o3}}),new o.Constructed({name:t.certificates||o4,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:iL.schema().valueBlock.value}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:iZ.schema(t.crls||{names:{crls:o8}}).valueBlock.value}),new o.Set({value:[new o.Repeated({name:t.signerInfos||o5,value:oC.schema()})]})]})}fromSchema(e){h.ze(e,o6);let t=o.compareSchema(e,e,o7.schema());if(S.assertSchema(t,this.className),this.version=t.result[o0].valueBlock.valueDec,o2 in t.result&&(this.digestAlgorithms=Array.from(t.result[o2],e=>new T({schema:e}))),this.encapContentInfo=new uH({schema:t.result[o3]}),o4 in t.result){let e=new iL({schema:new o.Set({value:t.result[o4].valueBlock.value})});this.certificates=e.certificates.slice(0)}o8 in t.result&&(this.crls=Array.from(t.result[o8],e=>1===e.idBlock.tagClass?new iu({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new iz({schema:e})))),o5 in t.result&&(this.signerInfos=Array.from(t.result[o5],e=>new oC({schema:e})))}toSchema(e=!1){let t=[];if(this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof ij)||this.crls&&this.crls.length&&this.crls.some(e=>e instanceof iz)?this.version=5:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof rs)?this.version=4:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof sP)||this.signerInfos.some(e=>3===e.version)||this.encapContentInfo.eContentType!==o7.ID_DATA?this.version=3:this.version=1,t.push(new o.Integer({value:this.version})),t.push(new o.Set({value:Array.from(this.digestAlgorithms,e=>e.toSchema())})),t.push(this.encapContentInfo.toSchema()),this.certificates){let e=new iL({certificates:this.certificates}),a=e.toSchema();t.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:a.valueBlock.value}))}return this.crls&&t.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,t=>{if(t instanceof iz){let e=t.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}return t.toSchema(e)})})),t.push(new o.Set({value:Array.from(this.signerInfos,e=>e.toSchema())})),new o.Sequence({value:t})}toJSON(){let e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,e=>e.toJSON()),encapContentInfo:this.encapContentInfo.toJSON(),signerInfos:Array.from(this.signerInfos,e=>e.toJSON())};return this.certificates&&(e.certificates=Array.from(this.certificates,e=>e.toJSON())),this.crls&&(e.crls=Array.from(this.crls,e=>e.toJSON())),e}async verify({signer:e=-1,data:t=f,trustedCerts:a=[],checkDate:s=new Date,checkChain:r=!1,passedWhenNotRevValues:i=!1,extendedMode:n=!1,findOrigin:l=null,findIssuer:u=null}={},o=aM(!0)){let c=null,m=null;try{let d=f,g="",p=[],S=this.signerInfos[e];if(!S)throw new o9({date:s,code:1,message:"Unable to get signer by supplied index"});if(!this.certificates)throw new o9({date:s,code:2,message:"No certificates attached to this signed data"});if(S.sid instanceof i8){for(let e of this.certificates)if(e instanceof rj&&e.issuer.isEqual(S.sid.issuer)&&e.serialNumber.isEqual(S.sid.serialNumber)){c=e;break}}else{let e=S.sid,t=e.idBlock.isConstructed?e.valueBlock.value[0].valueBlock.valueHex:e.valueBlock.valueHex;for(let e of this.certificates){if(!(e instanceof rj))continue;let a=await o.digest({name:"sha-1"},e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView);if(h.dN(a,t)){c=e;break}}}if(!c)throw new o9({date:s,code:3,message:"Unable to find signer certificate"});if("1.2.840.113549.1.9.16.1.4"===this.encapContentInfo.eContentType){let e;if(!this.encapContentInfo.eContent)throw new o9({date:s,code:15,message:"Error during verification: TSTInfo eContent is empty",signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0});try{e=oW.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView)}catch(e){throw new o9({date:s,code:15,message:"Error during verification: TSTInfo wrong ASN.1 schema ",signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0})}if(s=e.genTime,m=e.serialNumber.valueBlock.valueHexView.slice(),0===t.byteLength)throw new o9({date:s,code:4,message:"Missed detached data input array"});if(!await e.verify({data:t},o))throw new o9({date:s,code:15,message:"Error during verification: TSTInfo verification is failed",signatureVerified:!1,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0})}if(r){let e=this.certificates.filter(e=>e instanceof rj&&!!rU(e,c)),t={checkDate:s,certs:e,trustedCerts:a};u&&(t.findIssuer=u),l&&(t.findOrigin=l);let r=new l9(t);if(r.certs.push(c),this.crls)for(let e of this.crls)"thisUpdate"in e?r.crls.push(e):e.otherRevInfoFormat===eC&&r.ocsps.push(new uo({schema:e.otherRevInfo}));this.ocsps&&r.ocsps.push(...this.ocsps);let n=await r.verify({passedWhenNotRevValues:i},o).catch(e=>{throw new o9({date:s,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signerCertificate:c,signerCertificateVerified:!1})});if(n.certificatePath&&(p=n.certificatePath),!n.result)throw new o9({date:s,code:5,message:`Validation of signer's certificate failed: ${n.resultMessage}`,signerCertificate:c,signerCertificateVerified:!1})}let y=o.getAlgorithmByOID(S.digestAlgorithm.algorithmId);if(!("name"in y))throw new o9({date:s,code:7,message:`Unsupported signature algorithm: ${S.digestAlgorithm.algorithmId}`,signerCertificate:c,signerCertificateVerified:!0});g=y.name;let w=this.encapContentInfo.eContent;if(w)t=1===w.idBlock.tagClass&&4===w.idBlock.tagNumber?w.getValue():w.valueBlock.valueBeforeDecodeView;else if(0===t.byteLength)throw new o9({date:s,code:8,message:"Missed detached data input array",signerCertificate:c,signerCertificateVerified:!0});if(S.signedAttrs){let e=!1,t=!1;for(let a of S.signedAttrs.attributes)if("1.2.840.113549.1.9.3"===a.type&&(e=!0),"1.2.840.113549.1.9.4"===a.type&&(t=!0,d=a.values[0].valueBlock.valueHex),e&&t)break;if(!1===e)throw new o9({date:s,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signerCertificate:c,signerCertificateVerified:!0});if(!1===t)throw new o9({date:s,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:c,signerCertificateVerified:!0})}if(S.signedAttrs){let e=await o.digest(g,new Uint8Array(t));if(!h.dN(e,d))throw new o9({date:s,code:15,message:"Error during verification: Message digest doesn't match",signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0});t=S.signedAttrs.encodedValue}let v=await o.verifyWithPublicKey(t,S.signature,c.subjectPublicKeyInfo,c.signatureAlgorithm,g);if(n)return{date:s,code:14,message:"",signatureVerified:v,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0,certificatePath:p};return v}catch(e){if(e instanceof o9)throw e;throw new o9({date:s,code:15,message:`Error during verification: ${e instanceof Error?e.message:e}`,signatureVerified:null,signerCertificate:c,timestampSerial:m,signerCertificateVerified:!0})}}async sign(e,t,a="SHA-1",s=f,r=aM(!0)){if(!e)throw Error("Need to provide a private key for signing");let i=r.getOIDByAlgorithm({name:a},!0,"hashAlgorithm");0===this.digestAlgorithms.filter(e=>e.algorithmId===i).length&&this.digestAlgorithms.push(new T({algorithmId:i,algorithmParams:new o.Null}));let n=this.signerInfos[t];if(!n)throw RangeError("SignerInfo index is out of range");n.digestAlgorithm=new T({algorithmId:i,algorithmParams:new o.Null});let l=await r.getSignatureParameters(e,a),u=l.parameters;if(n.signatureAlgorithm=l.signatureAlgorithm,n.signedAttrs){if(0!==n.signedAttrs.encodedValue.byteLength)s=n.signedAttrs.encodedValue;else{s=n.signedAttrs.toSchema().toBER();let e=c.vJ.toUint8Array(s);e[0]=49}}else{let e=this.encapContentInfo.eContent;if(e)s=1===e.idBlock.tagClass&&4===e.idBlock.tagNumber?e.getValue():e.valueBlock.valueBeforeDecodeView;else if(0===s.byteLength)throw Error("Missed detached data input array")}let h=await r.signWithPrivateKey(s,e,u);n.signature=new o.OctetString({valueHex:h})}}o7.CLASS_NAME="SignedData",o7.ID_DATA=eS;let ce="version",ct="authSafe",ca="macData",cs="parsedValue",cr=[ce,ct,ca];class ci extends y{constructor(e={}){super(),this.version=h.H$(e,ce,ci.defaultValues(ce)),this.authSafe=h.H$(e,ct,ci.defaultValues(ct)),ca in e&&(this.macData=h.H$(e,ca,ci.defaultValues(ca))),cs in e&&(this.parsedValue=h.H$(e,cs,ci.defaultValues(cs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ce:return 3;case ct:return new rl;case ca:return new u$;case cs:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ce:return t===ci.defaultValues(e);case ct:return rl.compareWithDefault("contentType",t.contentType)&&rl.compareWithDefault("content",t.content);case ca:return u$.compareWithDefault("mac",t.mac)&&u$.compareWithDefault("macSalt",t.macSalt)&&u$.compareWithDefault("iterations",t.iterations);case cs:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.version||ce}),rl.schema(t.authSafe||{names:{blockName:ct}}),u$.schema(t.macData||{names:{blockName:ca,optional:!0}})]})}fromSchema(e){h.ze(e,cr);let t=o.compareSchema(e,e,ci.schema({names:{version:ce,authSafe:{names:{blockName:ct}},macData:{names:{blockName:ca}}}}));S.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.authSafe=new rl({schema:t.result.authSafe}),ca in t.result&&(this.macData=new u$({schema:t.result.macData}))}toSchema(){let e=[new o.Integer({value:this.version}),this.authSafe.toSchema()];return this.macData&&e.push(this.macData.toSchema()),new o.Sequence({value:e})}toJSON(){let e={version:this.version,authSafe:this.authSafe.toJSON()};return this.macData&&(e.macData=this.macData.toJSON()),e}async makeInternalValues(e={},t=aM(!0)){if(g.assert(e,"parameters","object"),!this.parsedValue)throw Error('Please call "parseValues" function first in order to make "parsedValue" data');switch(p.assertEmpty(this.parsedValue.integrityMode,"integrityMode","parsedValue"),p.assertEmpty(this.parsedValue.authenticatedSafe,"authenticatedSafe","parsedValue"),this.parsedValue.integrityMode){case 0:{if(!("iterations"in e))throw new p("iterations");p.assertEmpty(e.pbkdf2HashAlgorithm,"pbkdf2HashAlgorithm"),p.assertEmpty(e.hmacHashAlgorithm,"hmacHashAlgorithm"),p.assertEmpty(e.password,"password");let a=new ArrayBuffer(64),s=new Uint8Array(a);t.getRandomValues(s);let r=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new rl({contentType:rl.DATA,content:new o.OctetString({valueHex:r})});let i=await t.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:a,iterationCount:e.iterations,contentToStamp:r});this.macData=new u$({mac:new uV({digestAlgorithm:new T({algorithmId:t.getOIDByAlgorithm({name:e.hmacHashAlgorithm},!0,"hmacHashAlgorithm")}),digest:new o.OctetString({valueHex:i})}),macSalt:new o.OctetString({valueHex:a}),iterations:e.iterations})}break;case 1:{if(!("signingCertificate"in e))throw new p("signingCertificate");p.assertEmpty(e.privateKey,"privateKey"),p.assertEmpty(e.hashAlgorithm,"hashAlgorithm");let a=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),s=new o7({version:1,encapContentInfo:new uH({eContentType:"1.2.840.113549.1.7.1",eContent:new o.OctetString({valueHex:a})}),certificates:[e.signingCertificate]}),r=await t.digest({name:e.hashAlgorithm},new Uint8Array(a)),i=[];i.push(new G({type:"1.2.840.113549.1.9.3",values:[new o.ObjectIdentifier({value:"1.2.840.113549.1.7.1"})]})),i.push(new G({type:"1.2.840.113549.1.9.5",values:[new o.UTCTime({valueDate:new Date})]})),i.push(new G({type:"1.2.840.113549.1.9.4",values:[new o.OctetString({valueHex:r})]})),s.signerInfos.push(new oC({version:1,sid:new i8({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new ou({type:0,attributes:i})})),await s.sign(e.privateKey,0,e.hashAlgorithm,void 0,t),this.authSafe=new rl({contentType:"1.2.840.113549.1.7.2",content:s.toSchema(!0)})}break;default:throw Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`)}}async parseInternalValues(e,t=aM(!0)){switch(g.assert(e,"parameters","object"),void 0===e.checkIntegrity&&(e.checkIntegrity=!0),this.parsedValue={},this.authSafe.contentType){case rl.DATA:{p.assertEmpty(e.password,"password"),this.parsedValue.integrityMode=0,g.assert(this.authSafe.content,"authSafe.content",o.OctetString);let a=this.authSafe.content.getValue();if(this.parsedValue.authenticatedSafe=lI.fromBER(a),e.checkIntegrity){if(!this.macData)throw Error('Absent "macData" value, can not check PKCS#12 data integrity');let s=t.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId,!0,"digestAlgorithm"),r=await t.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:s.name,salt:c.vJ.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),iterationCount:this.macData.iterations||1,contentToVerify:a,signatureToVerify:c.vJ.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)});if(!r)throw Error("Integrity for the PKCS#12 data is broken!")}}break;case rl.SIGNED_DATA:{this.parsedValue.integrityMode=1;let e=new o7({schema:this.authSafe.content}),a=e.encapContentInfo.eContent;p.assert(a,"eContent","cmsSigned.encapContentInfo"),g.assert(a,"eContent",o.OctetString);let s=a.getValue();this.parsedValue.authenticatedSafe=lI.fromBER(s);let r=await e.verify({signer:0,checkChain:!1},t);if(!r)throw Error("Integrity for the PKCS#12 data is broken!")}break;default:throw Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}}}ci.CLASS_NAME="PFX";let cn="status",cl="statusStrings",cu="failInfo",co=[cn,cl,cu];(i=u||(u={}))[i.granted=0]="granted",i[i.grantedWithMods=1]="grantedWithMods",i[i.rejection=2]="rejection",i[i.waiting=3]="waiting",i[i.revocationWarning=4]="revocationWarning",i[i.revocationNotification=5]="revocationNotification";class cc extends y{constructor(e={}){super(),this.status=h.H$(e,cn,cc.defaultValues(cn)),cl in e&&(this.statusStrings=h.H$(e,cl,cc.defaultValues(cl))),cu in e&&(this.failInfo=h.H$(e,cu,cc.defaultValues(cu))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cn:return 2;case cl:return[];case cu:return new o.BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cn:return t===cc.defaultValues(e);case cl:return 0===t.length;case cu:return t.isEqual(cc.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||"",value:[new o.Integer({name:t.status||""}),new o.Sequence({optional:!0,value:[new o.Repeated({name:t.statusStrings||"",value:new o.Utf8String})]}),new o.BitString({name:t.failInfo||"",optional:!0})]})}fromSchema(e){h.ze(e,co);let t=o.compareSchema(e,e,cc.schema({names:{status:cn,statusStrings:cl,failInfo:cu}}));S.assertSchema(t,this.className);let a=t.result.status;if(!0===a.valueBlock.isHexOnly||a.valueBlock.valueDec<0||a.valueBlock.valueDec>5)throw Error('PKIStatusInfo "status" has invalid value');this.status=a.valueBlock.valueDec,cl in t.result&&(this.statusStrings=t.result.statusStrings),cu in t.result&&(this.failInfo=t.result.failInfo)}toSchema(){let e=[];return e.push(new o.Integer({value:this.status})),this.statusStrings&&e.push(new o.Sequence({optional:!0,value:this.statusStrings})),this.failInfo&&e.push(this.failInfo),new o.Sequence({value:e})}toJSON(){let e={status:this.status};return this.statusStrings&&(e.statusStrings=Array.from(this.statusStrings,e=>e.toJSON())),this.failInfo&&(e.failInfo=this.failInfo.toJSON()),e}}cc.CLASS_NAME="PKIStatusInfo";let ch="version",cm="messageImprint",cd="reqPolicy",cf="nonce",cg="certReq",cp="extensions",cS="TimeStampReq",cy=`${cS}.${ch}`,cw=`${cS}.${cm}`,cv=`${cS}.${cd}`,cb=`${cS}.${cf}`,cA=`${cS}.${cg}`,ck=`${cS}.${cp}`,cC=[cy,cw,cv,cb,cA,ck];class cN extends y{constructor(e={}){super(),this.version=h.H$(e,ch,cN.defaultValues(ch)),this.messageImprint=h.H$(e,cm,cN.defaultValues(cm)),cd in e&&(this.reqPolicy=h.H$(e,cd,cN.defaultValues(cd))),cf in e&&(this.nonce=h.H$(e,cf,cN.defaultValues(cf))),cg in e&&(this.certReq=h.H$(e,cg,cN.defaultValues(cg))),cp in e&&(this.extensions=h.H$(e,cp,cN.defaultValues(cp))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ch:return 0;case cm:return new uR;case cd:return"";case cf:return new o.Integer;case cg:return!1;case cp:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ch:case cd:case cg:return t===cN.defaultValues(e);case cm:return uR.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&uR.compareWithDefault("hashedMessage",t.hashedMessage);case cf:return t.isEqual(cN.defaultValues(e));case cp:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||cS,value:[new o.Integer({name:t.version||cy}),uR.schema(t.messageImprint||{names:{blockName:cw}}),new o.ObjectIdentifier({name:t.reqPolicy||cv,optional:!0}),new o.Integer({name:t.nonce||cb,optional:!0}),new o.Boolean({name:t.certReq||cA,optional:!0}),new o.Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new o.Repeated({name:t.extensions||ck,value:sc.schema()})]})]})}fromSchema(e){h.ze(e,cC);let t=o.compareSchema(e,e,cN.schema());S.assertSchema(t,this.className),this.version=t.result[cy].valueBlock.valueDec,this.messageImprint=new uR({schema:t.result[cw]}),cv in t.result&&(this.reqPolicy=t.result[cv].valueBlock.toString()),cb in t.result&&(this.nonce=t.result[cb]),cA in t.result&&(this.certReq=t.result[cA].valueBlock.value),ck in t.result&&(this.extensions=Array.from(t.result[ck],e=>new sc({schema:e})))}toSchema(){let e=[];return e.push(new o.Integer({value:this.version})),e.push(this.messageImprint.toSchema()),this.reqPolicy&&e.push(new o.ObjectIdentifier({value:this.reqPolicy})),this.nonce&&e.push(this.nonce),cg in this&&!1===cN.compareWithDefault(cg,this.certReq)&&e.push(new o.Boolean({value:this.certReq})),this.extensions&&e.push(new o.Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.extensions,e=>e.toSchema())})),new o.Sequence({value:e})}toJSON(){let e={version:this.version,messageImprint:this.messageImprint.toJSON()};return void 0!==this.reqPolicy&&(e.reqPolicy=this.reqPolicy),void 0!==this.nonce&&(e.nonce=this.nonce.toJSON()),void 0!==this.certReq&&!1===cN.compareWithDefault(cg,this.certReq)&&(e.certReq=this.certReq),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}}cN.CLASS_NAME="TimeStampReq";let cV="status",cI="timeStampToken",cB="TimeStampResp",cE=`${cB}.${cV}`,cH=`${cB}.${cI}`,cD=[cE,cH];class cO extends y{constructor(e={}){super(),this.status=h.H$(e,cV,cO.defaultValues(cV)),cI in e&&(this.timeStampToken=h.H$(e,cI,cO.defaultValues(cI))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cV:return new cc;case cI:return new rl;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cV:return cc.compareWithDefault(cV,t.status)&&"statusStrings"in t==!1&&"failInfo"in t==!1;case cI:return""===t.contentType&&t.content instanceof o.Any;default:return super.defaultValues(e)}}static schema(e={}){let t=h.H$(e,"names",{});return new o.Sequence({name:t.blockName||cB,value:[cc.schema(t.status||{names:{blockName:cE}}),rl.schema(t.timeStampToken||{names:{blockName:cH,optional:!0}})]})}fromSchema(e){h.ze(e,cD);let t=o.compareSchema(e,e,cO.schema());S.assertSchema(t,this.className),this.status=new cc({schema:t.result[cE]}),cH in t.result&&(this.timeStampToken=new rl({schema:t.result[cH]}))}toSchema(){let e=[];return e.push(this.status.toSchema()),this.timeStampToken&&e.push(this.timeStampToken.toSchema()),new o.Sequence({value:e})}toJSON(){let e={status:this.status.toJSON()};return this.timeStampToken&&(e.timeStampToken=this.timeStampToken.toJSON()),e}async sign(e,t,a=aM(!0)){this.assertContentType();let s=new o7({schema:this.timeStampToken.content});return s.sign(e,0,t,void 0,a)}async verify(e={signer:0,trustedCerts:[],data:f},t=aM(!0)){this.assertContentType();let a=new o7({schema:this.timeStampToken.content});return a.verify(e,t)}assertContentType(){if(!this.timeStampToken)throw Error("timeStampToken is absent in TSP response");if(this.timeStampToken.contentType!==ey)throw Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`)}}cO.CLASS_NAME="TimeStampResp",function(){if("undefined"!=typeof self){if("crypto"in self){let e="webcrypto";"webkitSubtle"in self.crypto&&(e="safari"),aL(e,new aj({name:e,crypto:crypto}))}}else if("undefined"!=typeof crypto&&"webcrypto"in crypto){let e="NodeJS ^15",t=crypto.webcrypto;aL(e,new aj({name:e,crypto:t}))}}()}}]);